# Generated from dafny.g4 by ANTLR 4.13.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,93,930,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,59,
        7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,65,
        2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,72,
        7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,78,
        2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,85,
        7,85,2,86,7,86,1,0,1,0,1,1,1,1,1,2,1,2,1,3,1,3,1,4,1,4,1,5,1,5,1,
        6,1,6,1,7,1,7,1,8,1,8,1,8,1,8,3,8,195,8,8,1,9,5,9,198,8,9,10,9,12,
        9,201,9,9,1,10,1,10,1,10,1,10,5,10,207,8,10,10,10,12,10,210,9,10,
        1,10,1,10,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,
        1,11,3,11,226,8,11,1,12,1,12,1,12,1,13,1,13,1,13,1,14,1,14,1,14,
        1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,17,1,17,1,17,1,17,1,17,5,17,
        249,8,17,10,17,12,17,252,9,17,1,18,1,18,3,18,256,8,18,1,19,1,19,
        1,19,3,19,261,8,19,1,19,1,19,1,19,1,19,5,19,267,8,19,10,19,12,19,
        270,9,19,3,19,272,8,19,1,19,1,19,5,19,276,8,19,10,19,12,19,279,9,
        19,1,19,1,19,1,20,1,20,1,20,1,20,1,20,3,20,288,8,20,1,21,1,21,1,
        21,1,21,1,21,1,21,5,21,296,8,21,10,21,12,21,299,9,21,3,21,301,8,
        21,1,21,1,21,5,21,305,8,21,10,21,12,21,308,9,21,1,21,1,21,1,22,1,
        22,1,22,3,22,315,8,22,1,23,1,23,1,23,3,23,320,8,23,1,23,1,23,1,23,
        1,23,5,23,326,8,23,10,23,12,23,329,9,23,1,24,1,24,1,24,3,24,334,
        8,24,1,24,1,24,1,24,3,24,339,8,24,1,24,5,24,342,8,24,10,24,12,24,
        345,9,24,1,25,1,25,1,25,3,25,350,8,25,1,25,1,25,5,25,354,8,25,10,
        25,12,25,357,9,25,1,26,1,26,1,26,1,27,1,27,1,27,3,27,365,8,27,1,
        28,1,28,1,28,1,28,5,28,371,8,28,10,28,12,28,374,9,28,3,28,376,8,
        28,1,28,1,28,1,29,1,29,1,29,1,29,1,29,1,30,1,30,1,30,1,30,1,30,1,
        31,1,31,1,31,1,31,1,31,1,32,1,32,1,32,5,32,398,8,32,10,32,12,32,
        401,9,32,1,32,1,32,1,32,1,32,1,33,1,33,1,33,1,34,1,34,1,34,1,34,
        1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,
        1,34,1,34,1,34,1,34,1,34,1,34,1,34,3,34,434,8,34,1,34,1,34,1,34,
        1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,
        1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,1,34,
        1,34,1,34,5,34,467,8,34,10,34,12,34,470,9,34,1,34,1,34,1,34,1,34,
        1,34,1,34,1,34,1,34,1,34,5,34,481,8,34,10,34,12,34,484,9,34,1,35,
        1,35,1,35,1,35,1,36,1,36,1,36,1,36,1,37,1,37,1,37,1,37,1,37,1,38,
        1,38,1,38,1,38,1,38,3,38,504,8,38,1,39,1,39,1,39,1,39,5,39,510,8,
        39,10,39,12,39,513,9,39,5,39,515,8,39,10,39,12,39,518,9,39,1,39,
        1,39,1,40,1,40,1,40,1,41,1,41,1,41,1,41,1,42,1,42,1,42,1,43,1,43,
        1,43,1,43,1,43,1,43,3,43,538,8,43,1,43,3,43,541,8,43,1,43,1,43,1,
        43,1,43,1,44,1,44,1,44,1,44,4,44,551,8,44,11,44,12,44,552,1,44,1,
        44,1,45,1,45,1,45,1,45,1,45,1,46,1,46,1,46,1,46,1,47,1,47,1,47,1,
        47,5,47,570,8,47,10,47,12,47,573,9,47,1,47,1,47,1,48,3,48,578,8,
        48,1,48,1,48,1,48,1,48,5,48,584,8,48,10,48,12,48,587,9,48,3,48,589,
        8,48,1,48,1,48,1,49,1,49,1,49,1,49,1,49,1,49,1,49,1,50,1,50,1,50,
        1,50,5,50,604,8,50,10,50,12,50,607,9,50,3,50,609,8,50,1,50,1,50,
        1,51,1,51,1,51,1,51,1,51,1,51,5,51,619,8,51,10,51,12,51,622,9,51,
        1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,1,52,5,52,633,8,52,10,52,
        12,52,636,9,52,3,52,638,8,52,1,52,1,52,1,53,1,53,1,53,1,53,1,53,
        1,53,1,53,1,53,1,53,1,54,1,54,1,54,1,54,1,55,1,55,1,55,1,55,1,55,
        1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,55,3,55,668,8,55,1,56,1,56,
        1,56,1,56,1,57,1,57,1,57,1,58,1,58,1,58,1,59,1,59,1,59,1,59,1,59,
        5,59,685,8,59,10,59,12,59,688,9,59,1,59,1,59,5,59,692,8,59,10,59,
        12,59,695,9,59,1,60,1,60,1,60,3,60,700,8,60,1,61,1,61,1,61,5,61,
        705,8,61,10,61,12,61,708,9,61,1,61,3,61,711,8,61,1,62,1,62,1,62,
        1,62,5,62,717,8,62,10,62,12,62,720,9,62,1,63,1,63,1,63,3,63,725,
        8,63,1,63,1,63,3,63,729,8,63,1,63,1,63,1,64,1,64,1,65,1,65,1,65,
        5,65,738,8,65,10,65,12,65,741,9,65,1,65,1,65,1,65,1,65,5,65,747,
        8,65,10,65,12,65,750,9,65,1,65,1,65,1,66,1,66,1,66,1,66,5,66,758,
        8,66,10,66,12,66,761,9,66,1,66,1,66,1,67,1,67,1,67,1,67,1,68,1,68,
        1,68,1,68,4,68,773,8,68,11,68,12,68,774,1,68,1,68,1,69,1,69,1,69,
        1,69,1,69,1,70,1,70,1,70,1,70,1,70,1,70,3,70,790,8,70,1,70,1,70,
        1,70,1,70,1,70,1,70,1,70,1,70,3,70,800,8,70,1,71,1,71,1,71,1,71,
        1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,71,1,72,1,72,1,72,1,72,1,72,
        1,72,1,72,1,72,1,72,1,72,1,73,1,73,1,73,1,73,1,73,1,73,3,73,830,
        8,73,1,73,5,73,833,8,73,10,73,12,73,836,9,73,1,73,1,73,1,73,1,73,
        1,74,1,74,1,74,1,74,3,74,846,8,74,1,75,1,75,1,75,1,75,1,75,1,75,
        3,75,854,8,75,1,76,1,76,1,76,1,77,1,77,1,77,3,77,862,8,77,1,78,1,
        78,1,78,3,78,867,8,78,1,79,1,79,1,79,3,79,872,8,79,1,80,1,80,1,80,
        1,80,5,80,878,8,80,10,80,12,80,881,9,80,1,80,3,80,884,8,80,1,81,
        1,81,1,81,3,81,889,8,81,1,82,1,82,1,82,1,82,1,82,3,82,896,8,82,1,
        82,1,82,1,82,3,82,901,8,82,1,83,1,83,1,83,1,83,1,83,1,83,1,84,1,
        84,1,84,1,84,5,84,913,8,84,10,84,12,84,916,9,84,1,84,1,84,1,85,1,
        85,3,85,922,8,85,1,86,5,86,925,8,86,10,86,12,86,928,9,86,1,86,0,
        1,68,87,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,
        42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,
        86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,
        122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,
        154,156,158,160,162,164,166,168,170,172,0,7,1,0,60,61,1,0,56,57,
        1,0,63,65,2,0,61,62,77,78,1,0,66,71,1,0,75,76,1,0,72,73,977,0,174,
        1,0,0,0,2,176,1,0,0,0,4,178,1,0,0,0,6,180,1,0,0,0,8,182,1,0,0,0,
        10,184,1,0,0,0,12,186,1,0,0,0,14,188,1,0,0,0,16,194,1,0,0,0,18,199,
        1,0,0,0,20,202,1,0,0,0,22,225,1,0,0,0,24,227,1,0,0,0,26,230,1,0,
        0,0,28,233,1,0,0,0,30,236,1,0,0,0,32,239,1,0,0,0,34,242,1,0,0,0,
        36,253,1,0,0,0,38,257,1,0,0,0,40,287,1,0,0,0,42,289,1,0,0,0,44,314,
        1,0,0,0,46,316,1,0,0,0,48,330,1,0,0,0,50,346,1,0,0,0,52,358,1,0,
        0,0,54,361,1,0,0,0,56,366,1,0,0,0,58,379,1,0,0,0,60,384,1,0,0,0,
        62,389,1,0,0,0,64,394,1,0,0,0,66,406,1,0,0,0,68,433,1,0,0,0,70,485,
        1,0,0,0,72,489,1,0,0,0,74,493,1,0,0,0,76,503,1,0,0,0,78,505,1,0,
        0,0,80,521,1,0,0,0,82,524,1,0,0,0,84,528,1,0,0,0,86,531,1,0,0,0,
        88,546,1,0,0,0,90,556,1,0,0,0,92,561,1,0,0,0,94,565,1,0,0,0,96,577,
        1,0,0,0,98,592,1,0,0,0,100,599,1,0,0,0,102,612,1,0,0,0,104,627,1,
        0,0,0,106,641,1,0,0,0,108,650,1,0,0,0,110,667,1,0,0,0,112,669,1,
        0,0,0,114,673,1,0,0,0,116,676,1,0,0,0,118,679,1,0,0,0,120,696,1,
        0,0,0,122,710,1,0,0,0,124,712,1,0,0,0,126,721,1,0,0,0,128,732,1,
        0,0,0,130,734,1,0,0,0,132,753,1,0,0,0,134,764,1,0,0,0,136,768,1,
        0,0,0,138,778,1,0,0,0,140,783,1,0,0,0,142,801,1,0,0,0,144,813,1,
        0,0,0,146,823,1,0,0,0,148,841,1,0,0,0,150,853,1,0,0,0,152,855,1,
        0,0,0,154,858,1,0,0,0,156,863,1,0,0,0,158,868,1,0,0,0,160,873,1,
        0,0,0,162,885,1,0,0,0,164,890,1,0,0,0,166,902,1,0,0,0,168,908,1,
        0,0,0,170,921,1,0,0,0,172,926,1,0,0,0,174,175,5,81,0,0,175,1,1,0,
        0,0,176,177,5,82,0,0,177,3,1,0,0,0,178,179,5,83,0,0,179,5,1,0,0,
        0,180,181,5,85,0,0,181,7,1,0,0,0,182,183,5,84,0,0,183,9,1,0,0,0,
        184,185,7,0,0,0,185,11,1,0,0,0,186,187,5,86,0,0,187,13,1,0,0,0,188,
        189,5,87,0,0,189,15,1,0,0,0,190,195,3,34,17,0,191,195,3,38,19,0,
        192,195,3,42,21,0,193,195,3,170,85,0,194,190,1,0,0,0,194,191,1,0,
        0,0,194,192,1,0,0,0,194,193,1,0,0,0,195,17,1,0,0,0,196,198,3,110,
        55,0,197,196,1,0,0,0,198,201,1,0,0,0,199,197,1,0,0,0,199,200,1,0,
        0,0,200,19,1,0,0,0,201,199,1,0,0,0,202,203,5,68,0,0,203,208,3,22,
        11,0,204,205,5,1,0,0,205,207,3,22,11,0,206,204,1,0,0,0,207,210,1,
        0,0,0,208,206,1,0,0,0,208,209,1,0,0,0,209,211,1,0,0,0,210,208,1,
        0,0,0,211,212,5,70,0,0,212,21,1,0,0,0,213,226,5,17,0,0,214,226,5,
        20,0,0,215,226,5,19,0,0,216,226,5,16,0,0,217,226,5,21,0,0,218,226,
        5,18,0,0,219,226,3,24,12,0,220,226,3,26,13,0,221,226,3,28,14,0,222,
        226,3,30,15,0,223,226,3,32,16,0,224,226,3,12,6,0,225,213,1,0,0,0,
        225,214,1,0,0,0,225,215,1,0,0,0,225,216,1,0,0,0,225,217,1,0,0,0,
        225,218,1,0,0,0,225,219,1,0,0,0,225,220,1,0,0,0,225,221,1,0,0,0,
        225,222,1,0,0,0,225,223,1,0,0,0,225,224,1,0,0,0,226,23,1,0,0,0,227,
        228,5,22,0,0,228,229,3,20,10,0,229,25,1,0,0,0,230,231,5,23,0,0,231,
        232,3,20,10,0,232,27,1,0,0,0,233,234,5,24,0,0,234,235,3,20,10,0,
        235,29,1,0,0,0,236,237,5,25,0,0,237,238,3,20,10,0,238,31,1,0,0,0,
        239,240,5,26,0,0,240,241,3,20,10,0,241,33,1,0,0,0,242,243,5,27,0,
        0,243,244,3,12,6,0,244,245,5,2,0,0,245,250,3,36,18,0,246,247,5,3,
        0,0,247,249,3,36,18,0,248,246,1,0,0,0,249,252,1,0,0,0,250,248,1,
        0,0,0,250,251,1,0,0,0,251,35,1,0,0,0,252,250,1,0,0,0,253,255,3,12,
        6,0,254,256,3,56,28,0,255,254,1,0,0,0,255,256,1,0,0,0,256,37,1,0,
        0,0,257,258,5,29,0,0,258,260,3,12,6,0,259,261,3,20,10,0,260,259,
        1,0,0,0,260,261,1,0,0,0,261,271,1,0,0,0,262,263,5,30,0,0,263,268,
        3,12,6,0,264,265,5,1,0,0,265,267,3,12,6,0,266,264,1,0,0,0,267,270,
        1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,272,1,0,0,0,270,268,
        1,0,0,0,271,262,1,0,0,0,271,272,1,0,0,0,272,273,1,0,0,0,273,277,
        5,4,0,0,274,276,3,40,20,0,275,274,1,0,0,0,276,279,1,0,0,0,277,275,
        1,0,0,0,277,278,1,0,0,0,278,280,1,0,0,0,279,277,1,0,0,0,280,281,
        5,5,0,0,281,39,1,0,0,0,282,288,3,52,26,0,283,288,3,58,29,0,284,288,
        3,60,30,0,285,288,3,64,32,0,286,288,3,62,31,0,287,282,1,0,0,0,287,
        283,1,0,0,0,287,284,1,0,0,0,287,285,1,0,0,0,287,286,1,0,0,0,288,
        41,1,0,0,0,289,290,5,28,0,0,290,300,3,12,6,0,291,292,5,30,0,0,292,
        297,3,12,6,0,293,294,5,1,0,0,294,296,3,12,6,0,295,293,1,0,0,0,296,
        299,1,0,0,0,297,295,1,0,0,0,297,298,1,0,0,0,298,301,1,0,0,0,299,
        297,1,0,0,0,300,291,1,0,0,0,300,301,1,0,0,0,301,302,1,0,0,0,302,
        306,5,4,0,0,303,305,3,44,22,0,304,303,1,0,0,0,305,308,1,0,0,0,306,
        304,1,0,0,0,306,307,1,0,0,0,307,309,1,0,0,0,308,306,1,0,0,0,309,
        310,5,5,0,0,310,43,1,0,0,0,311,315,3,52,26,0,312,315,3,46,23,0,313,
        315,3,48,24,0,314,311,1,0,0,0,314,312,1,0,0,0,314,313,1,0,0,0,315,
        45,1,0,0,0,316,319,5,32,0,0,317,320,3,14,7,0,318,320,3,12,6,0,319,
        317,1,0,0,0,319,318,1,0,0,0,320,321,1,0,0,0,321,322,3,56,28,0,322,
        323,5,6,0,0,323,327,3,22,11,0,324,326,3,150,75,0,325,324,1,0,0,0,
        326,329,1,0,0,0,327,325,1,0,0,0,327,328,1,0,0,0,328,47,1,0,0,0,329,
        327,1,0,0,0,330,333,5,31,0,0,331,334,3,14,7,0,332,334,3,12,6,0,333,
        331,1,0,0,0,333,332,1,0,0,0,334,335,1,0,0,0,335,338,3,56,28,0,336,
        337,5,34,0,0,337,339,3,56,28,0,338,336,1,0,0,0,338,339,1,0,0,0,339,
        343,1,0,0,0,340,342,3,150,75,0,341,340,1,0,0,0,342,345,1,0,0,0,343,
        341,1,0,0,0,343,344,1,0,0,0,344,49,1,0,0,0,345,343,1,0,0,0,346,349,
        5,33,0,0,347,350,3,14,7,0,348,350,3,12,6,0,349,347,1,0,0,0,349,348,
        1,0,0,0,350,351,1,0,0,0,351,355,3,56,28,0,352,354,3,150,75,0,353,
        352,1,0,0,0,354,357,1,0,0,0,355,353,1,0,0,0,355,356,1,0,0,0,356,
        51,1,0,0,0,357,355,1,0,0,0,358,359,7,1,0,0,359,360,3,54,27,0,360,
        53,1,0,0,0,361,364,3,14,7,0,362,363,5,6,0,0,363,365,3,22,11,0,364,
        362,1,0,0,0,364,365,1,0,0,0,365,55,1,0,0,0,366,375,5,7,0,0,367,372,
        3,54,27,0,368,369,5,1,0,0,369,371,3,54,27,0,370,368,1,0,0,0,371,
        374,1,0,0,0,372,370,1,0,0,0,372,373,1,0,0,0,373,376,1,0,0,0,374,
        372,1,0,0,0,375,367,1,0,0,0,375,376,1,0,0,0,376,377,1,0,0,0,377,
        378,5,8,0,0,378,57,1,0,0,0,379,380,3,46,23,0,380,381,5,4,0,0,381,
        382,3,68,34,0,382,383,5,5,0,0,383,59,1,0,0,0,384,385,3,48,24,0,385,
        386,5,4,0,0,386,387,3,18,9,0,387,388,5,5,0,0,388,61,1,0,0,0,389,
        390,3,50,25,0,390,391,5,4,0,0,391,392,3,68,34,0,392,393,5,5,0,0,
        393,63,1,0,0,0,394,395,5,35,0,0,395,399,3,56,28,0,396,398,3,150,
        75,0,397,396,1,0,0,0,398,401,1,0,0,0,399,397,1,0,0,0,399,400,1,0,
        0,0,400,402,1,0,0,0,401,399,1,0,0,0,402,403,5,4,0,0,403,404,3,18,
        9,0,404,405,5,5,0,0,405,65,1,0,0,0,406,407,5,60,0,0,407,408,5,60,
        0,0,408,67,1,0,0,0,409,410,6,34,-1,0,410,434,3,72,36,0,411,434,3,
        74,37,0,412,434,3,82,41,0,413,434,3,84,42,0,414,434,3,80,40,0,415,
        434,3,86,43,0,416,434,3,88,44,0,417,434,3,92,46,0,418,434,3,76,38,
        0,419,434,3,96,48,0,420,434,3,98,49,0,421,434,3,100,50,0,422,434,
        3,102,51,0,423,434,3,104,52,0,424,434,3,106,53,0,425,434,3,14,7,
        0,426,427,5,7,0,0,427,428,3,68,34,0,428,429,5,8,0,0,429,434,1,0,
        0,0,430,431,3,10,5,0,431,432,3,68,34,8,432,434,1,0,0,0,433,409,1,
        0,0,0,433,411,1,0,0,0,433,412,1,0,0,0,433,413,1,0,0,0,433,414,1,
        0,0,0,433,415,1,0,0,0,433,416,1,0,0,0,433,417,1,0,0,0,433,418,1,
        0,0,0,433,419,1,0,0,0,433,420,1,0,0,0,433,421,1,0,0,0,433,422,1,
        0,0,0,433,423,1,0,0,0,433,424,1,0,0,0,433,425,1,0,0,0,433,426,1,
        0,0,0,433,430,1,0,0,0,434,482,1,0,0,0,435,436,10,12,0,0,436,437,
        5,79,0,0,437,481,3,68,34,13,438,439,10,7,0,0,439,440,7,2,0,0,440,
        481,3,68,34,8,441,442,10,6,0,0,442,443,7,3,0,0,443,481,3,68,34,7,
        444,445,10,5,0,0,445,446,7,4,0,0,446,481,3,68,34,6,447,448,10,4,
        0,0,448,449,7,5,0,0,449,481,3,68,34,5,450,451,10,3,0,0,451,452,7,
        6,0,0,452,481,3,68,34,4,453,454,10,2,0,0,454,455,3,66,33,0,455,456,
        3,68,34,3,456,481,1,0,0,0,457,458,10,1,0,0,458,459,5,74,0,0,459,
        481,3,68,34,2,460,461,10,13,0,0,461,462,5,79,0,0,462,463,5,7,0,0,
        463,468,3,70,35,0,464,465,5,1,0,0,465,467,3,70,35,0,466,464,1,0,
        0,0,467,470,1,0,0,0,468,466,1,0,0,0,468,469,1,0,0,0,469,471,1,0,
        0,0,470,468,1,0,0,0,471,472,5,8,0,0,472,481,1,0,0,0,473,474,10,11,
        0,0,474,475,5,9,0,0,475,476,3,108,54,0,476,477,5,10,0,0,477,481,
        1,0,0,0,478,479,10,9,0,0,479,481,3,94,47,0,480,435,1,0,0,0,480,438,
        1,0,0,0,480,441,1,0,0,0,480,444,1,0,0,0,480,447,1,0,0,0,480,450,
        1,0,0,0,480,453,1,0,0,0,480,457,1,0,0,0,480,460,1,0,0,0,480,473,
        1,0,0,0,480,478,1,0,0,0,481,484,1,0,0,0,482,480,1,0,0,0,482,483,
        1,0,0,0,483,69,1,0,0,0,484,482,1,0,0,0,485,486,3,14,7,0,486,487,
        5,11,0,0,487,488,3,68,34,0,488,71,1,0,0,0,489,490,5,3,0,0,490,491,
        3,68,34,0,491,492,5,3,0,0,492,73,1,0,0,0,493,494,5,25,0,0,494,495,
        5,7,0,0,495,496,3,68,34,0,496,497,5,8,0,0,497,75,1,0,0,0,498,504,
        3,0,0,0,499,504,3,2,1,0,500,504,3,4,2,0,501,504,3,6,3,0,502,504,
        3,8,4,0,503,498,1,0,0,0,503,499,1,0,0,0,503,500,1,0,0,0,503,501,
        1,0,0,0,503,502,1,0,0,0,504,77,1,0,0,0,505,516,5,7,0,0,506,511,3,
        68,34,0,507,508,5,1,0,0,508,510,3,68,34,0,509,507,1,0,0,0,510,513,
        1,0,0,0,511,509,1,0,0,0,511,512,1,0,0,0,512,515,1,0,0,0,513,511,
        1,0,0,0,514,506,1,0,0,0,515,518,1,0,0,0,516,514,1,0,0,0,516,517,
        1,0,0,0,517,519,1,0,0,0,518,516,1,0,0,0,519,520,5,8,0,0,520,79,1,
        0,0,0,521,522,3,120,60,0,522,523,3,78,39,0,523,81,1,0,0,0,524,525,
        5,58,0,0,525,526,3,12,6,0,526,527,3,78,39,0,527,83,1,0,0,0,528,529,
        3,12,6,0,529,530,3,78,39,0,530,85,1,0,0,0,531,537,5,37,0,0,532,533,
        5,7,0,0,533,534,3,68,34,0,534,535,5,8,0,0,535,538,1,0,0,0,536,538,
        3,68,34,0,537,532,1,0,0,0,537,536,1,0,0,0,538,540,1,0,0,0,539,541,
        5,39,0,0,540,539,1,0,0,0,540,541,1,0,0,0,541,542,1,0,0,0,542,543,
        3,68,34,0,543,544,5,38,0,0,544,545,3,68,34,0,545,87,1,0,0,0,546,
        547,5,47,0,0,547,548,3,68,34,0,548,550,5,4,0,0,549,551,3,90,45,0,
        550,549,1,0,0,0,551,552,1,0,0,0,552,550,1,0,0,0,552,553,1,0,0,0,
        553,554,1,0,0,0,554,555,5,5,0,0,555,89,1,0,0,0,556,557,5,48,0,0,
        557,558,3,68,34,0,558,559,5,12,0,0,559,560,3,68,34,0,560,91,1,0,
        0,0,561,562,3,120,60,0,562,563,5,79,0,0,563,564,5,36,0,0,564,93,
        1,0,0,0,565,566,5,9,0,0,566,571,3,68,34,0,567,568,5,1,0,0,568,570,
        3,68,34,0,569,567,1,0,0,0,570,573,1,0,0,0,571,569,1,0,0,0,571,572,
        1,0,0,0,572,574,1,0,0,0,573,571,1,0,0,0,574,575,5,10,0,0,575,95,
        1,0,0,0,576,578,5,25,0,0,577,576,1,0,0,0,577,578,1,0,0,0,578,579,
        1,0,0,0,579,588,5,4,0,0,580,585,3,68,34,0,581,582,5,1,0,0,582,584,
        3,68,34,0,583,581,1,0,0,0,584,587,1,0,0,0,585,583,1,0,0,0,585,586,
        1,0,0,0,586,589,1,0,0,0,587,585,1,0,0,0,588,580,1,0,0,0,588,589,
        1,0,0,0,589,590,1,0,0,0,590,591,5,5,0,0,591,97,1,0,0,0,592,593,5,
        24,0,0,593,594,3,54,27,0,594,595,5,3,0,0,595,596,3,68,34,0,596,597,
        5,13,0,0,597,598,3,68,34,0,598,99,1,0,0,0,599,608,5,9,0,0,600,605,
        3,68,34,0,601,602,5,1,0,0,602,604,3,68,34,0,603,601,1,0,0,0,604,
        607,1,0,0,0,605,603,1,0,0,0,605,606,1,0,0,0,606,609,1,0,0,0,607,
        605,1,0,0,0,608,600,1,0,0,0,608,609,1,0,0,0,609,610,1,0,0,0,610,
        611,5,10,0,0,611,101,1,0,0,0,612,613,5,26,0,0,613,614,5,7,0,0,614,
        615,3,68,34,0,615,616,5,1,0,0,616,620,3,14,7,0,617,619,3,150,75,
        0,618,617,1,0,0,0,619,622,1,0,0,0,620,618,1,0,0,0,620,621,1,0,0,
        0,621,623,1,0,0,0,622,620,1,0,0,0,623,624,5,12,0,0,624,625,3,68,
        34,0,625,626,5,8,0,0,626,103,1,0,0,0,627,628,5,23,0,0,628,637,5,
        9,0,0,629,634,3,108,54,0,630,631,5,1,0,0,631,633,3,108,54,0,632,
        630,1,0,0,0,633,636,1,0,0,0,634,632,1,0,0,0,634,635,1,0,0,0,635,
        638,1,0,0,0,636,634,1,0,0,0,637,629,1,0,0,0,637,638,1,0,0,0,638,
        639,1,0,0,0,639,640,5,10,0,0,640,105,1,0,0,0,641,642,5,23,0,0,642,
        643,3,54,27,0,643,644,5,3,0,0,644,645,3,68,34,0,645,646,5,13,0,0,
        646,647,3,68,34,0,647,648,5,11,0,0,648,649,3,68,34,0,649,107,1,0,
        0,0,650,651,3,68,34,0,651,652,5,11,0,0,652,653,3,68,34,0,653,109,
        1,0,0,0,654,668,3,112,56,0,655,668,3,114,57,0,656,668,3,116,58,0,
        657,668,3,134,67,0,658,668,3,126,63,0,659,668,3,130,65,0,660,668,
        3,132,66,0,661,668,3,136,68,0,662,668,3,140,70,0,663,668,3,142,71,
        0,664,668,3,144,72,0,665,668,3,146,73,0,666,668,3,148,74,0,667,654,
        1,0,0,0,667,655,1,0,0,0,667,656,1,0,0,0,667,657,1,0,0,0,667,658,
        1,0,0,0,667,659,1,0,0,0,667,660,1,0,0,0,667,661,1,0,0,0,667,662,
        1,0,0,0,667,663,1,0,0,0,667,664,1,0,0,0,667,665,1,0,0,0,667,666,
        1,0,0,0,668,111,1,0,0,0,669,670,5,49,0,0,670,671,3,68,34,0,671,672,
        5,80,0,0,672,113,1,0,0,0,673,674,5,40,0,0,674,675,5,80,0,0,675,115,
        1,0,0,0,676,677,5,41,0,0,677,678,5,80,0,0,678,117,1,0,0,0,679,693,
        3,14,7,0,680,681,5,9,0,0,681,686,3,68,34,0,682,683,5,1,0,0,683,685,
        3,68,34,0,684,682,1,0,0,0,685,688,1,0,0,0,686,684,1,0,0,0,686,687,
        1,0,0,0,687,689,1,0,0,0,688,686,1,0,0,0,689,690,5,10,0,0,690,692,
        1,0,0,0,691,680,1,0,0,0,692,695,1,0,0,0,693,691,1,0,0,0,693,694,
        1,0,0,0,694,119,1,0,0,0,695,693,1,0,0,0,696,699,3,118,59,0,697,698,
        5,79,0,0,698,700,3,120,60,0,699,697,1,0,0,0,699,700,1,0,0,0,700,
        121,1,0,0,0,701,706,3,68,34,0,702,703,5,1,0,0,703,705,3,68,34,0,
        704,702,1,0,0,0,705,708,1,0,0,0,706,704,1,0,0,0,706,707,1,0,0,0,
        707,711,1,0,0,0,708,706,1,0,0,0,709,711,3,164,82,0,710,701,1,0,0,
        0,710,709,1,0,0,0,711,123,1,0,0,0,712,713,5,56,0,0,713,718,3,120,
        60,0,714,715,5,1,0,0,715,717,3,120,60,0,716,714,1,0,0,0,717,720,
        1,0,0,0,718,716,1,0,0,0,718,719,1,0,0,0,719,125,1,0,0,0,720,718,
        1,0,0,0,721,724,3,124,62,0,722,723,5,6,0,0,723,725,3,22,11,0,724,
        722,1,0,0,0,724,725,1,0,0,0,725,728,1,0,0,0,726,727,5,11,0,0,727,
        729,3,122,61,0,728,726,1,0,0,0,728,729,1,0,0,0,729,730,1,0,0,0,730,
        731,5,80,0,0,731,127,1,0,0,0,732,733,3,120,60,0,733,129,1,0,0,0,
        734,739,3,128,64,0,735,736,5,1,0,0,736,738,3,128,64,0,737,735,1,
        0,0,0,738,741,1,0,0,0,739,737,1,0,0,0,739,740,1,0,0,0,740,742,1,
        0,0,0,741,739,1,0,0,0,742,743,5,11,0,0,743,748,3,122,61,0,744,745,
        5,1,0,0,745,747,3,122,61,0,746,744,1,0,0,0,747,750,1,0,0,0,748,746,
        1,0,0,0,748,749,1,0,0,0,749,751,1,0,0,0,750,748,1,0,0,0,751,752,
        5,80,0,0,752,131,1,0,0,0,753,754,5,46,0,0,754,759,3,68,34,0,755,
        756,5,1,0,0,756,758,3,68,34,0,757,755,1,0,0,0,758,761,1,0,0,0,759,
        757,1,0,0,0,759,760,1,0,0,0,760,762,1,0,0,0,761,759,1,0,0,0,762,
        763,5,80,0,0,763,133,1,0,0,0,764,765,3,120,60,0,765,766,3,78,39,
        0,766,767,5,80,0,0,767,135,1,0,0,0,768,769,5,47,0,0,769,770,3,68,
        34,0,770,772,5,4,0,0,771,773,3,138,69,0,772,771,1,0,0,0,773,774,
        1,0,0,0,774,772,1,0,0,0,774,775,1,0,0,0,775,776,1,0,0,0,776,777,
        5,5,0,0,777,137,1,0,0,0,778,779,5,48,0,0,779,780,3,68,34,0,780,781,
        5,12,0,0,781,782,3,18,9,0,782,139,1,0,0,0,783,789,5,37,0,0,784,785,
        5,7,0,0,785,786,3,68,34,0,786,787,5,8,0,0,787,790,1,0,0,0,788,790,
        3,68,34,0,789,784,1,0,0,0,789,788,1,0,0,0,790,791,1,0,0,0,791,792,
        5,4,0,0,792,793,3,18,9,0,793,799,5,5,0,0,794,795,5,38,0,0,795,796,
        5,4,0,0,796,797,3,18,9,0,797,798,5,5,0,0,798,800,1,0,0,0,799,794,
        1,0,0,0,799,800,1,0,0,0,800,141,1,0,0,0,801,802,5,43,0,0,802,803,
        3,14,7,0,803,804,5,3,0,0,804,805,3,68,34,0,805,806,5,69,0,0,806,
        807,3,14,7,0,807,808,5,68,0,0,808,809,3,68,34,0,809,810,5,4,0,0,
        810,811,3,130,65,0,811,812,5,5,0,0,812,143,1,0,0,0,813,814,5,44,
        0,0,814,815,3,14,7,0,815,816,5,11,0,0,816,817,3,68,34,0,817,818,
        5,45,0,0,818,819,3,68,34,0,819,820,5,4,0,0,820,821,3,18,9,0,821,
        822,5,5,0,0,822,145,1,0,0,0,823,829,5,42,0,0,824,825,5,7,0,0,825,
        826,3,68,34,0,826,827,5,8,0,0,827,830,1,0,0,0,828,830,3,68,34,0,
        829,824,1,0,0,0,829,828,1,0,0,0,830,834,1,0,0,0,831,833,3,150,75,
        0,832,831,1,0,0,0,833,836,1,0,0,0,834,832,1,0,0,0,834,835,1,0,0,
        0,835,837,1,0,0,0,836,834,1,0,0,0,837,838,5,4,0,0,838,839,3,18,9,
        0,839,840,5,5,0,0,840,147,1,0,0,0,841,842,5,59,0,0,842,843,5,56,
        0,0,843,845,3,54,27,0,844,846,5,80,0,0,845,844,1,0,0,0,845,846,1,
        0,0,0,846,149,1,0,0,0,847,854,3,152,76,0,848,854,3,154,77,0,849,
        854,3,156,78,0,850,854,3,158,79,0,851,854,3,160,80,0,852,854,3,162,
        81,0,853,847,1,0,0,0,853,848,1,0,0,0,853,849,1,0,0,0,853,850,1,0,
        0,0,853,851,1,0,0,0,853,852,1,0,0,0,854,151,1,0,0,0,855,856,5,50,
        0,0,856,857,3,68,34,0,857,153,1,0,0,0,858,859,5,51,0,0,859,861,3,
        68,34,0,860,862,5,80,0,0,861,860,1,0,0,0,861,862,1,0,0,0,862,155,
        1,0,0,0,863,864,5,55,0,0,864,866,3,68,34,0,865,867,5,80,0,0,866,
        865,1,0,0,0,866,867,1,0,0,0,867,157,1,0,0,0,868,869,5,54,0,0,869,
        871,3,14,7,0,870,872,5,80,0,0,871,870,1,0,0,0,871,872,1,0,0,0,872,
        159,1,0,0,0,873,874,5,53,0,0,874,875,3,14,7,0,875,879,5,1,0,0,876,
        878,3,14,7,0,877,876,1,0,0,0,878,881,1,0,0,0,879,877,1,0,0,0,879,
        880,1,0,0,0,880,883,1,0,0,0,881,879,1,0,0,0,882,884,5,80,0,0,883,
        882,1,0,0,0,883,884,1,0,0,0,884,161,1,0,0,0,885,886,5,52,0,0,886,
        888,3,68,34,0,887,889,5,80,0,0,888,887,1,0,0,0,888,889,1,0,0,0,889,
        163,1,0,0,0,890,891,5,58,0,0,891,892,3,22,11,0,892,895,5,9,0,0,893,
        896,3,2,1,0,894,896,3,68,34,0,895,893,1,0,0,0,895,894,1,0,0,0,896,
        897,1,0,0,0,897,900,5,10,0,0,898,901,3,166,83,0,899,901,3,168,84,
        0,900,898,1,0,0,0,900,899,1,0,0,0,900,901,1,0,0,0,901,165,1,0,0,
        0,902,903,5,7,0,0,903,904,3,14,7,0,904,905,5,12,0,0,905,906,3,68,
        34,0,906,907,5,8,0,0,907,167,1,0,0,0,908,909,5,9,0,0,909,914,3,68,
        34,0,910,911,5,1,0,0,911,913,3,68,34,0,912,910,1,0,0,0,913,916,1,
        0,0,0,914,912,1,0,0,0,914,915,1,0,0,0,915,917,1,0,0,0,916,914,1,
        0,0,0,917,918,5,10,0,0,918,169,1,0,0,0,919,922,3,58,29,0,920,922,
        3,60,30,0,921,919,1,0,0,0,921,920,1,0,0,0,922,171,1,0,0,0,923,925,
        3,16,8,0,924,923,1,0,0,0,925,928,1,0,0,0,926,924,1,0,0,0,926,927,
        1,0,0,0,927,173,1,0,0,0,928,926,1,0,0,0,75,194,199,208,225,250,255,
        260,268,271,277,287,297,300,306,314,319,327,333,338,343,349,355,
        364,372,375,399,433,468,480,482,503,511,516,537,540,552,571,577,
        585,588,605,608,620,634,637,667,686,693,699,706,710,718,724,728,
        739,748,759,774,789,799,829,834,845,853,861,866,871,879,883,888,
        895,900,914,921,926
    ]

class dafnyParser ( Parser ):

    grammarFileName = "dafny.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "','", "'='", "'|'", "'{'", "'}'", "':'", 
                     "'('", "')'", "'['", "']'", "':='", "'=>'", "'::'", 
                     "<INVALID>", "<INVALID>", "'bool'", "'int'", "'nat'", 
                     "'real'", "'char'", "'string'", "'array'", "'map'", 
                     "'set'", "'multiset'", "'seq'", "'datatype'", "'trait'", 
                     "'class'", "'extends'", "'method'", "'function'", "'predicate'", 
                     "'returns'", "'constructor'", "'Length'", "'if'", "'else'", 
                     "'then'", "'break'", "'continue'", "'while'", "'forall'", 
                     "'for'", "'to'", "'print'", "'match'", "'case'", "'assert'", 
                     "'decreases'", "'ensures'", "'requires'", "'reads'", 
                     "'modifies'", "'invariant'", "'var'", "'const'", "'new'", 
                     "'ghost'", "'!'", "'-'", "'+'", "'%'", "'/'", "'*'", 
                     "'=='", "'!='", "'<'", "'<='", "'>'", "'>='", "'==>'", 
                     "'<=='", "'<==>'", "'&&'", "'||'", "'in'", "'!in'", 
                     "'.'", "';'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "WHITESPACE", "COMMENT", 
                      "BOOL", "INT", "NAT", "REAL", "CHAR", "STRING", "ARRAY", 
                      "MAP", "SET", "MULTISET", "SEQUENCE", "DATATYPE", 
                      "TRAIT", "CLASS", "EXTENDS", "METHOD", "FUNCTION", 
                      "PREDICATE", "RETURNS", "CONSTRUCTOR", "LENGTH", "IF", 
                      "ELSE", "THEN", "BREAK", "CONTINUE", "WHILE", "FORALL", 
                      "FOR", "TO", "PRINT", "MATCH", "CASE", "ASSERT", "DECREASES", 
                      "ENSURES", "REQUIRES", "READS", "MODIFIES", "INVARIANT", 
                      "VAR", "CONST", "NEW", "GHOST", "NOT", "NEG", "ADD", 
                      "MOD", "DIV", "MUL", "EQ", "NEQ", "LT", "LEQ", "GT", 
                      "GEQ", "IMP", "RIMP", "IFF", "AND", "OR", "IN", "NOT_IN", 
                      "DOT", "SEMICOLON", "BOOL_LITERAL", "INT_LITERAL", 
                      "REAL_LITERAL", "STRING_LITERAL", "CHAR_LITERAL", 
                      "UPPER_IDENTIFIER", "IDENTIFIER", "NON_DIGIT_ID_CHAR", 
                      "SPECIAL_CHAR", "ID_CHAR", "ESCAPED_CHAR", "CHAR_CHAR", 
                      "STRING_CHAR" ]

    RULE_boolLiteral = 0
    RULE_intLiteral = 1
    RULE_realLiteral = 2
    RULE_charLiteral = 3
    RULE_stringToken = 4
    RULE_unaryOperator = 5
    RULE_upperIdentifier = 6
    RULE_identifier = 7
    RULE_topDecl = 8
    RULE_sequence = 9
    RULE_genericInstantiation = 10
    RULE_type = 11
    RULE_arrayType = 12
    RULE_mapType = 13
    RULE_setType = 14
    RULE_multisetType = 15
    RULE_sequenceType = 16
    RULE_datatypeDecl = 17
    RULE_datatypeConstructor = 18
    RULE_classDecl = 19
    RULE_classMemberDecl = 20
    RULE_traitDecl = 21
    RULE_traitMemberDecl = 22
    RULE_functionSignatureDecl = 23
    RULE_methodSignatureDecl = 24
    RULE_predicateSignatureDecl = 25
    RULE_fieldDecl = 26
    RULE_identifierType = 27
    RULE_parameters = 28
    RULE_functionDecl = 29
    RULE_methodDecl = 30
    RULE_predicateDecl = 31
    RULE_constructorDecl = 32
    RULE_disj = 33
    RULE_expression = 34
    RULE_datatypeFieldUpdate = 35
    RULE_modulus = 36
    RULE_multisetConversion = 37
    RULE_literal = 38
    RULE_callParameters = 39
    RULE_functionCall = 40
    RULE_classInstantiation = 41
    RULE_datatypeInstantiation = 42
    RULE_ternaryExpression = 43
    RULE_matchExpression = 44
    RULE_caseExpression = 45
    RULE_arrayLength = 46
    RULE_index = 47
    RULE_setDisplay = 48
    RULE_setComprehension = 49
    RULE_sequenceDisplay = 50
    RULE_sequenceComprehension = 51
    RULE_mapConstructor = 52
    RULE_mapComprehension = 53
    RULE_indexElem = 54
    RULE_statement = 55
    RULE_assertStatement = 56
    RULE_breakStatement = 57
    RULE_continueStatement = 58
    RULE_declIdentifier = 59
    RULE_declAssignLhs = 60
    RULE_declAssignRhs = 61
    RULE_declarationLhs = 62
    RULE_declaration = 63
    RULE_assignmentLhs = 64
    RULE_assignment = 65
    RULE_print = 66
    RULE_voidMethodCall = 67
    RULE_matchStatement = 68
    RULE_caseStatement = 69
    RULE_ifStatement = 70
    RULE_forallStatement = 71
    RULE_forLoop = 72
    RULE_whileStatement = 73
    RULE_ghostVarDecl = 74
    RULE_verifierAnnotation = 75
    RULE_decreases = 76
    RULE_ensures = 77
    RULE_invariant = 78
    RULE_modifies = 79
    RULE_reads = 80
    RULE_requires = 81
    RULE_arrayConstructor = 82
    RULE_arrayComprehension = 83
    RULE_arrayValues = 84
    RULE_topDeclMember = 85
    RULE_program = 86

    ruleNames =  [ "boolLiteral", "intLiteral", "realLiteral", "charLiteral", 
                   "stringToken", "unaryOperator", "upperIdentifier", "identifier", 
                   "topDecl", "sequence", "genericInstantiation", "type", 
                   "arrayType", "mapType", "setType", "multisetType", "sequenceType", 
                   "datatypeDecl", "datatypeConstructor", "classDecl", "classMemberDecl", 
                   "traitDecl", "traitMemberDecl", "functionSignatureDecl", 
                   "methodSignatureDecl", "predicateSignatureDecl", "fieldDecl", 
                   "identifierType", "parameters", "functionDecl", "methodDecl", 
                   "predicateDecl", "constructorDecl", "disj", "expression", 
                   "datatypeFieldUpdate", "modulus", "multisetConversion", 
                   "literal", "callParameters", "functionCall", "classInstantiation", 
                   "datatypeInstantiation", "ternaryExpression", "matchExpression", 
                   "caseExpression", "arrayLength", "index", "setDisplay", 
                   "setComprehension", "sequenceDisplay", "sequenceComprehension", 
                   "mapConstructor", "mapComprehension", "indexElem", "statement", 
                   "assertStatement", "breakStatement", "continueStatement", 
                   "declIdentifier", "declAssignLhs", "declAssignRhs", "declarationLhs", 
                   "declaration", "assignmentLhs", "assignment", "print", 
                   "voidMethodCall", "matchStatement", "caseStatement", 
                   "ifStatement", "forallStatement", "forLoop", "whileStatement", 
                   "ghostVarDecl", "verifierAnnotation", "decreases", "ensures", 
                   "invariant", "modifies", "reads", "requires", "arrayConstructor", 
                   "arrayComprehension", "arrayValues", "topDeclMember", 
                   "program" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    WHITESPACE=14
    COMMENT=15
    BOOL=16
    INT=17
    NAT=18
    REAL=19
    CHAR=20
    STRING=21
    ARRAY=22
    MAP=23
    SET=24
    MULTISET=25
    SEQUENCE=26
    DATATYPE=27
    TRAIT=28
    CLASS=29
    EXTENDS=30
    METHOD=31
    FUNCTION=32
    PREDICATE=33
    RETURNS=34
    CONSTRUCTOR=35
    LENGTH=36
    IF=37
    ELSE=38
    THEN=39
    BREAK=40
    CONTINUE=41
    WHILE=42
    FORALL=43
    FOR=44
    TO=45
    PRINT=46
    MATCH=47
    CASE=48
    ASSERT=49
    DECREASES=50
    ENSURES=51
    REQUIRES=52
    READS=53
    MODIFIES=54
    INVARIANT=55
    VAR=56
    CONST=57
    NEW=58
    GHOST=59
    NOT=60
    NEG=61
    ADD=62
    MOD=63
    DIV=64
    MUL=65
    EQ=66
    NEQ=67
    LT=68
    LEQ=69
    GT=70
    GEQ=71
    IMP=72
    RIMP=73
    IFF=74
    AND=75
    OR=76
    IN=77
    NOT_IN=78
    DOT=79
    SEMICOLON=80
    BOOL_LITERAL=81
    INT_LITERAL=82
    REAL_LITERAL=83
    STRING_LITERAL=84
    CHAR_LITERAL=85
    UPPER_IDENTIFIER=86
    IDENTIFIER=87
    NON_DIGIT_ID_CHAR=88
    SPECIAL_CHAR=89
    ID_CHAR=90
    ESCAPED_CHAR=91
    CHAR_CHAR=92
    STRING_CHAR=93

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class BoolLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BOOL_LITERAL(self):
            return self.getToken(dafnyParser.BOOL_LITERAL, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_boolLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolLiteral" ):
                listener.enterBoolLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolLiteral" ):
                listener.exitBoolLiteral(self)




    def boolLiteral(self):

        localctx = dafnyParser.BoolLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_boolLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.match(dafnyParser.BOOL_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IntLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT_LITERAL(self):
            return self.getToken(dafnyParser.INT_LITERAL, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_intLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntLiteral" ):
                listener.enterIntLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntLiteral" ):
                listener.exitIntLiteral(self)




    def intLiteral(self):

        localctx = dafnyParser.IntLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_intLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            self.match(dafnyParser.INT_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RealLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REAL_LITERAL(self):
            return self.getToken(dafnyParser.REAL_LITERAL, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_realLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRealLiteral" ):
                listener.enterRealLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRealLiteral" ):
                listener.exitRealLiteral(self)




    def realLiteral(self):

        localctx = dafnyParser.RealLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_realLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 178
            self.match(dafnyParser.REAL_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CharLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHAR_LITERAL(self):
            return self.getToken(dafnyParser.CHAR_LITERAL, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_charLiteral

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharLiteral" ):
                listener.enterCharLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharLiteral" ):
                listener.exitCharLiteral(self)




    def charLiteral(self):

        localctx = dafnyParser.CharLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_charLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 180
            self.match(dafnyParser.CHAR_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StringTokenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(dafnyParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_stringToken

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStringToken" ):
                listener.enterStringToken(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStringToken" ):
                listener.exitStringToken(self)




    def stringToken(self):

        localctx = dafnyParser.StringTokenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_stringToken)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.match(dafnyParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnaryOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT(self):
            return self.getToken(dafnyParser.NOT, 0)

        def NEG(self):
            return self.getToken(dafnyParser.NEG, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_unaryOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnaryOperator" ):
                listener.enterUnaryOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnaryOperator" ):
                listener.exitUnaryOperator(self)




    def unaryOperator(self):

        localctx = dafnyParser.UnaryOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_unaryOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            _la = self._input.LA(1)
            if not(_la==60 or _la==61):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UpperIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPPER_IDENTIFIER(self):
            return self.getToken(dafnyParser.UPPER_IDENTIFIER, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_upperIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpperIdentifier" ):
                listener.enterUpperIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpperIdentifier" ):
                listener.exitUpperIdentifier(self)




    def upperIdentifier(self):

        localctx = dafnyParser.UpperIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_upperIdentifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(dafnyParser.UPPER_IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(dafnyParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = dafnyParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 188
            self.match(dafnyParser.IDENTIFIER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def datatypeDecl(self):
            return self.getTypedRuleContext(dafnyParser.DatatypeDeclContext,0)


        def classDecl(self):
            return self.getTypedRuleContext(dafnyParser.ClassDeclContext,0)


        def traitDecl(self):
            return self.getTypedRuleContext(dafnyParser.TraitDeclContext,0)


        def topDeclMember(self):
            return self.getTypedRuleContext(dafnyParser.TopDeclMemberContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_topDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopDecl" ):
                listener.enterTopDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopDecl" ):
                listener.exitTopDecl(self)




    def topDecl(self):

        localctx = dafnyParser.TopDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_topDecl)
        try:
            self.state = 194
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [27]:
                self.enterOuterAlt(localctx, 1)
                self.state = 190
                self.datatypeDecl()
                pass
            elif token in [29]:
                self.enterOuterAlt(localctx, 2)
                self.state = 191
                self.classDecl()
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 3)
                self.state = 192
                self.traitDecl()
                pass
            elif token in [31, 32]:
                self.enterOuterAlt(localctx, 4)
                self.state = 193
                self.topDeclMember()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SequenceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.StatementContext)
            else:
                return self.getTypedRuleContext(dafnyParser.StatementContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_sequence

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequence" ):
                listener.enterSequence(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequence" ):
                listener.exitSequence(self)




    def sequence(self):

        localctx = dafnyParser.SequenceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_sequence)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 37)) & ~0x3f) == 0 and ((1 << (_la - 37)) & 1125899911567097) != 0):
                self.state = 196
                self.statement()
                self.state = 201
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GenericInstantiationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(dafnyParser.LT, 0)

        def type_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.TypeContext)
            else:
                return self.getTypedRuleContext(dafnyParser.TypeContext,i)


        def GT(self):
            return self.getToken(dafnyParser.GT, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_genericInstantiation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenericInstantiation" ):
                listener.enterGenericInstantiation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenericInstantiation" ):
                listener.exitGenericInstantiation(self)




    def genericInstantiation(self):

        localctx = dafnyParser.GenericInstantiationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_genericInstantiation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            self.match(dafnyParser.LT)
            self.state = 203
            self.type_()
            self.state = 208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1:
                self.state = 204
                self.match(dafnyParser.T__0)
                self.state = 205
                self.type_()
                self.state = 210
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 211
            self.match(dafnyParser.GT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INT(self):
            return self.getToken(dafnyParser.INT, 0)

        def CHAR(self):
            return self.getToken(dafnyParser.CHAR, 0)

        def REAL(self):
            return self.getToken(dafnyParser.REAL, 0)

        def BOOL(self):
            return self.getToken(dafnyParser.BOOL, 0)

        def STRING(self):
            return self.getToken(dafnyParser.STRING, 0)

        def NAT(self):
            return self.getToken(dafnyParser.NAT, 0)

        def arrayType(self):
            return self.getTypedRuleContext(dafnyParser.ArrayTypeContext,0)


        def mapType(self):
            return self.getTypedRuleContext(dafnyParser.MapTypeContext,0)


        def setType(self):
            return self.getTypedRuleContext(dafnyParser.SetTypeContext,0)


        def multisetType(self):
            return self.getTypedRuleContext(dafnyParser.MultisetTypeContext,0)


        def sequenceType(self):
            return self.getTypedRuleContext(dafnyParser.SequenceTypeContext,0)


        def upperIdentifier(self):
            return self.getTypedRuleContext(dafnyParser.UpperIdentifierContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType" ):
                listener.enterType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType" ):
                listener.exitType(self)




    def type_(self):

        localctx = dafnyParser.TypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_type)
        try:
            self.state = 225
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [17]:
                self.enterOuterAlt(localctx, 1)
                self.state = 213
                self.match(dafnyParser.INT)
                pass
            elif token in [20]:
                self.enterOuterAlt(localctx, 2)
                self.state = 214
                self.match(dafnyParser.CHAR)
                pass
            elif token in [19]:
                self.enterOuterAlt(localctx, 3)
                self.state = 215
                self.match(dafnyParser.REAL)
                pass
            elif token in [16]:
                self.enterOuterAlt(localctx, 4)
                self.state = 216
                self.match(dafnyParser.BOOL)
                pass
            elif token in [21]:
                self.enterOuterAlt(localctx, 5)
                self.state = 217
                self.match(dafnyParser.STRING)
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 6)
                self.state = 218
                self.match(dafnyParser.NAT)
                pass
            elif token in [22]:
                self.enterOuterAlt(localctx, 7)
                self.state = 219
                self.arrayType()
                pass
            elif token in [23]:
                self.enterOuterAlt(localctx, 8)
                self.state = 220
                self.mapType()
                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 9)
                self.state = 221
                self.setType()
                pass
            elif token in [25]:
                self.enterOuterAlt(localctx, 10)
                self.state = 222
                self.multisetType()
                pass
            elif token in [26]:
                self.enterOuterAlt(localctx, 11)
                self.state = 223
                self.sequenceType()
                pass
            elif token in [86]:
                self.enterOuterAlt(localctx, 12)
                self.state = 224
                self.upperIdentifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(dafnyParser.ARRAY, 0)

        def genericInstantiation(self):
            return self.getTypedRuleContext(dafnyParser.GenericInstantiationContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_arrayType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayType" ):
                listener.enterArrayType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayType" ):
                listener.exitArrayType(self)




    def arrayType(self):

        localctx = dafnyParser.ArrayTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_arrayType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 227
            self.match(dafnyParser.ARRAY)
            self.state = 228
            self.genericInstantiation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MapTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAP(self):
            return self.getToken(dafnyParser.MAP, 0)

        def genericInstantiation(self):
            return self.getTypedRuleContext(dafnyParser.GenericInstantiationContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_mapType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMapType" ):
                listener.enterMapType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMapType" ):
                listener.exitMapType(self)




    def mapType(self):

        localctx = dafnyParser.MapTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_mapType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            self.match(dafnyParser.MAP)
            self.state = 231
            self.genericInstantiation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(dafnyParser.SET, 0)

        def genericInstantiation(self):
            return self.getTypedRuleContext(dafnyParser.GenericInstantiationContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_setType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetType" ):
                listener.enterSetType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetType" ):
                listener.exitSetType(self)




    def setType(self):

        localctx = dafnyParser.SetTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_setType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.match(dafnyParser.SET)
            self.state = 234
            self.genericInstantiation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultisetTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULTISET(self):
            return self.getToken(dafnyParser.MULTISET, 0)

        def genericInstantiation(self):
            return self.getTypedRuleContext(dafnyParser.GenericInstantiationContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_multisetType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultisetType" ):
                listener.enterMultisetType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultisetType" ):
                listener.exitMultisetType(self)




    def multisetType(self):

        localctx = dafnyParser.MultisetTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_multisetType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 236
            self.match(dafnyParser.MULTISET)
            self.state = 237
            self.genericInstantiation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SequenceTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEQUENCE(self):
            return self.getToken(dafnyParser.SEQUENCE, 0)

        def genericInstantiation(self):
            return self.getTypedRuleContext(dafnyParser.GenericInstantiationContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_sequenceType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequenceType" ):
                listener.enterSequenceType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequenceType" ):
                listener.exitSequenceType(self)




    def sequenceType(self):

        localctx = dafnyParser.SequenceTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_sequenceType)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 239
            self.match(dafnyParser.SEQUENCE)
            self.state = 240
            self.genericInstantiation()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatatypeDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATATYPE(self):
            return self.getToken(dafnyParser.DATATYPE, 0)

        def upperIdentifier(self):
            return self.getTypedRuleContext(dafnyParser.UpperIdentifierContext,0)


        def datatypeConstructor(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.DatatypeConstructorContext)
            else:
                return self.getTypedRuleContext(dafnyParser.DatatypeConstructorContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_datatypeDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatypeDecl" ):
                listener.enterDatatypeDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatypeDecl" ):
                listener.exitDatatypeDecl(self)




    def datatypeDecl(self):

        localctx = dafnyParser.DatatypeDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_datatypeDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 242
            self.match(dafnyParser.DATATYPE)
            self.state = 243
            self.upperIdentifier()
            self.state = 244
            self.match(dafnyParser.T__1)
            self.state = 245
            self.datatypeConstructor()
            self.state = 250
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==3:
                self.state = 246
                self.match(dafnyParser.T__2)
                self.state = 247
                self.datatypeConstructor()
                self.state = 252
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatatypeConstructorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def upperIdentifier(self):
            return self.getTypedRuleContext(dafnyParser.UpperIdentifierContext,0)


        def parameters(self):
            return self.getTypedRuleContext(dafnyParser.ParametersContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_datatypeConstructor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatypeConstructor" ):
                listener.enterDatatypeConstructor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatypeConstructor" ):
                listener.exitDatatypeConstructor(self)




    def datatypeConstructor(self):

        localctx = dafnyParser.DatatypeConstructorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_datatypeConstructor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 253
            self.upperIdentifier()
            self.state = 255
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 254
                self.parameters()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CLASS(self):
            return self.getToken(dafnyParser.CLASS, 0)

        def upperIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.UpperIdentifierContext)
            else:
                return self.getTypedRuleContext(dafnyParser.UpperIdentifierContext,i)


        def genericInstantiation(self):
            return self.getTypedRuleContext(dafnyParser.GenericInstantiationContext,0)


        def EXTENDS(self):
            return self.getToken(dafnyParser.EXTENDS, 0)

        def classMemberDecl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ClassMemberDeclContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ClassMemberDeclContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_classDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassDecl" ):
                listener.enterClassDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassDecl" ):
                listener.exitClassDecl(self)




    def classDecl(self):

        localctx = dafnyParser.ClassDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_classDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 257
            self.match(dafnyParser.CLASS)
            self.state = 258
            self.upperIdentifier()
            self.state = 260
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==68:
                self.state = 259
                self.genericInstantiation()


            self.state = 271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 262
                self.match(dafnyParser.EXTENDS)
                self.state = 263
                self.upperIdentifier()
                self.state = 268
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==1:
                    self.state = 264
                    self.match(dafnyParser.T__0)
                    self.state = 265
                    self.upperIdentifier()
                    self.state = 270
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 273
            self.match(dafnyParser.T__3)
            self.state = 277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 216172831505907712) != 0):
                self.state = 274
                self.classMemberDecl()
                self.state = 279
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 280
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassMemberDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fieldDecl(self):
            return self.getTypedRuleContext(dafnyParser.FieldDeclContext,0)


        def functionDecl(self):
            return self.getTypedRuleContext(dafnyParser.FunctionDeclContext,0)


        def methodDecl(self):
            return self.getTypedRuleContext(dafnyParser.MethodDeclContext,0)


        def constructorDecl(self):
            return self.getTypedRuleContext(dafnyParser.ConstructorDeclContext,0)


        def predicateDecl(self):
            return self.getTypedRuleContext(dafnyParser.PredicateDeclContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_classMemberDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassMemberDecl" ):
                listener.enterClassMemberDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassMemberDecl" ):
                listener.exitClassMemberDecl(self)




    def classMemberDecl(self):

        localctx = dafnyParser.ClassMemberDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_classMemberDecl)
        try:
            self.state = 287
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [56, 57]:
                self.enterOuterAlt(localctx, 1)
                self.state = 282
                self.fieldDecl()
                pass
            elif token in [32]:
                self.enterOuterAlt(localctx, 2)
                self.state = 283
                self.functionDecl()
                pass
            elif token in [31]:
                self.enterOuterAlt(localctx, 3)
                self.state = 284
                self.methodDecl()
                pass
            elif token in [35]:
                self.enterOuterAlt(localctx, 4)
                self.state = 285
                self.constructorDecl()
                pass
            elif token in [33]:
                self.enterOuterAlt(localctx, 5)
                self.state = 286
                self.predicateDecl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRAIT(self):
            return self.getToken(dafnyParser.TRAIT, 0)

        def upperIdentifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.UpperIdentifierContext)
            else:
                return self.getTypedRuleContext(dafnyParser.UpperIdentifierContext,i)


        def EXTENDS(self):
            return self.getToken(dafnyParser.EXTENDS, 0)

        def traitMemberDecl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.TraitMemberDeclContext)
            else:
                return self.getTypedRuleContext(dafnyParser.TraitMemberDeclContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_traitDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitDecl" ):
                listener.enterTraitDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitDecl" ):
                listener.exitTraitDecl(self)




    def traitDecl(self):

        localctx = dafnyParser.TraitDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_traitDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 289
            self.match(dafnyParser.TRAIT)
            self.state = 290
            self.upperIdentifier()
            self.state = 300
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==30:
                self.state = 291
                self.match(dafnyParser.EXTENDS)
                self.state = 292
                self.upperIdentifier()
                self.state = 297
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==1:
                    self.state = 293
                    self.match(dafnyParser.T__0)
                    self.state = 294
                    self.upperIdentifier()
                    self.state = 299
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 302
            self.match(dafnyParser.T__3)
            self.state = 306
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 216172788556234752) != 0):
                self.state = 303
                self.traitMemberDecl()
                self.state = 308
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 309
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TraitMemberDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def fieldDecl(self):
            return self.getTypedRuleContext(dafnyParser.FieldDeclContext,0)


        def functionSignatureDecl(self):
            return self.getTypedRuleContext(dafnyParser.FunctionSignatureDeclContext,0)


        def methodSignatureDecl(self):
            return self.getTypedRuleContext(dafnyParser.MethodSignatureDeclContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_traitMemberDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraitMemberDecl" ):
                listener.enterTraitMemberDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraitMemberDecl" ):
                listener.exitTraitMemberDecl(self)




    def traitMemberDecl(self):

        localctx = dafnyParser.TraitMemberDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_traitMemberDecl)
        try:
            self.state = 314
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [56, 57]:
                self.enterOuterAlt(localctx, 1)
                self.state = 311
                self.fieldDecl()
                pass
            elif token in [32]:
                self.enterOuterAlt(localctx, 2)
                self.state = 312
                self.functionSignatureDecl()
                pass
            elif token in [31]:
                self.enterOuterAlt(localctx, 3)
                self.state = 313
                self.methodSignatureDecl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionSignatureDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCTION(self):
            return self.getToken(dafnyParser.FUNCTION, 0)

        def parameters(self):
            return self.getTypedRuleContext(dafnyParser.ParametersContext,0)


        def type_(self):
            return self.getTypedRuleContext(dafnyParser.TypeContext,0)


        def identifier(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierContext,0)


        def upperIdentifier(self):
            return self.getTypedRuleContext(dafnyParser.UpperIdentifierContext,0)


        def verifierAnnotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.VerifierAnnotationContext)
            else:
                return self.getTypedRuleContext(dafnyParser.VerifierAnnotationContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_functionSignatureDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionSignatureDecl" ):
                listener.enterFunctionSignatureDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionSignatureDecl" ):
                listener.exitFunctionSignatureDecl(self)




    def functionSignatureDecl(self):

        localctx = dafnyParser.FunctionSignatureDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_functionSignatureDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 316
            self.match(dafnyParser.FUNCTION)
            self.state = 319
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [87]:
                self.state = 317
                self.identifier()
                pass
            elif token in [86]:
                self.state = 318
                self.upperIdentifier()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 321
            self.parameters()
            self.state = 322
            self.match(dafnyParser.T__5)
            self.state = 323
            self.type_()
            self.state = 327
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 70931694131085312) != 0):
                self.state = 324
                self.verifierAnnotation()
                self.state = 329
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodSignatureDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def METHOD(self):
            return self.getToken(dafnyParser.METHOD, 0)

        def parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ParametersContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ParametersContext,i)


        def identifier(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierContext,0)


        def upperIdentifier(self):
            return self.getTypedRuleContext(dafnyParser.UpperIdentifierContext,0)


        def RETURNS(self):
            return self.getToken(dafnyParser.RETURNS, 0)

        def verifierAnnotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.VerifierAnnotationContext)
            else:
                return self.getTypedRuleContext(dafnyParser.VerifierAnnotationContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_methodSignatureDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodSignatureDecl" ):
                listener.enterMethodSignatureDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodSignatureDecl" ):
                listener.exitMethodSignatureDecl(self)




    def methodSignatureDecl(self):

        localctx = dafnyParser.MethodSignatureDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_methodSignatureDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 330
            self.match(dafnyParser.METHOD)
            self.state = 333
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [87]:
                self.state = 331
                self.identifier()
                pass
            elif token in [86]:
                self.state = 332
                self.upperIdentifier()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 335
            self.parameters()
            self.state = 338
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==34:
                self.state = 336
                self.match(dafnyParser.RETURNS)
                self.state = 337
                self.parameters()


            self.state = 343
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 70931694131085312) != 0):
                self.state = 340
                self.verifierAnnotation()
                self.state = 345
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateSignatureDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PREDICATE(self):
            return self.getToken(dafnyParser.PREDICATE, 0)

        def parameters(self):
            return self.getTypedRuleContext(dafnyParser.ParametersContext,0)


        def identifier(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierContext,0)


        def upperIdentifier(self):
            return self.getTypedRuleContext(dafnyParser.UpperIdentifierContext,0)


        def verifierAnnotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.VerifierAnnotationContext)
            else:
                return self.getTypedRuleContext(dafnyParser.VerifierAnnotationContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_predicateSignatureDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicateSignatureDecl" ):
                listener.enterPredicateSignatureDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicateSignatureDecl" ):
                listener.exitPredicateSignatureDecl(self)




    def predicateSignatureDecl(self):

        localctx = dafnyParser.PredicateSignatureDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_predicateSignatureDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 346
            self.match(dafnyParser.PREDICATE)
            self.state = 349
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [87]:
                self.state = 347
                self.identifier()
                pass
            elif token in [86]:
                self.state = 348
                self.upperIdentifier()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 351
            self.parameters()
            self.state = 355
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 70931694131085312) != 0):
                self.state = 352
                self.verifierAnnotation()
                self.state = 357
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FieldDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierType(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierTypeContext,0)


        def VAR(self):
            return self.getToken(dafnyParser.VAR, 0)

        def CONST(self):
            return self.getToken(dafnyParser.CONST, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_fieldDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFieldDecl" ):
                listener.enterFieldDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFieldDecl" ):
                listener.exitFieldDecl(self)




    def fieldDecl(self):

        localctx = dafnyParser.FieldDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_fieldDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 358
            _la = self._input.LA(1)
            if not(_la==56 or _la==57):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 359
            self.identifierType()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierContext,0)


        def type_(self):
            return self.getTypedRuleContext(dafnyParser.TypeContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_identifierType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifierType" ):
                listener.enterIdentifierType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifierType" ):
                listener.exitIdentifierType(self)




    def identifierType(self):

        localctx = dafnyParser.IdentifierTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_identifierType)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 361
            self.identifier()
            self.state = 364
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 362
                self.match(dafnyParser.T__5)
                self.state = 363
                self.type_()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierType(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.IdentifierTypeContext)
            else:
                return self.getTypedRuleContext(dafnyParser.IdentifierTypeContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)




    def parameters(self):

        localctx = dafnyParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_parameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 366
            self.match(dafnyParser.T__6)
            self.state = 375
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==87:
                self.state = 367
                self.identifierType()
                self.state = 372
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==1:
                    self.state = 368
                    self.match(dafnyParser.T__0)
                    self.state = 369
                    self.identifierType()
                    self.state = 374
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 377
            self.match(dafnyParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionSignatureDecl(self):
            return self.getTypedRuleContext(dafnyParser.FunctionSignatureDeclContext,0)


        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_functionDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionDecl" ):
                listener.enterFunctionDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionDecl" ):
                listener.exitFunctionDecl(self)




    def functionDecl(self):

        localctx = dafnyParser.FunctionDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_functionDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 379
            self.functionSignatureDecl()
            self.state = 380
            self.match(dafnyParser.T__3)
            self.state = 381
            self.expression(0)
            self.state = 382
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MethodDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def methodSignatureDecl(self):
            return self.getTypedRuleContext(dafnyParser.MethodSignatureDeclContext,0)


        def sequence(self):
            return self.getTypedRuleContext(dafnyParser.SequenceContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_methodDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMethodDecl" ):
                listener.enterMethodDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMethodDecl" ):
                listener.exitMethodDecl(self)




    def methodDecl(self):

        localctx = dafnyParser.MethodDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_methodDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 384
            self.methodSignatureDecl()
            self.state = 385
            self.match(dafnyParser.T__3)
            self.state = 386
            self.sequence()
            self.state = 387
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PredicateDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicateSignatureDecl(self):
            return self.getTypedRuleContext(dafnyParser.PredicateSignatureDeclContext,0)


        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_predicateDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicateDecl" ):
                listener.enterPredicateDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicateDecl" ):
                listener.exitPredicateDecl(self)




    def predicateDecl(self):

        localctx = dafnyParser.PredicateDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_predicateDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 389
            self.predicateSignatureDecl()
            self.state = 390
            self.match(dafnyParser.T__3)
            self.state = 391
            self.expression(0)
            self.state = 392
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstructorDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTRUCTOR(self):
            return self.getToken(dafnyParser.CONSTRUCTOR, 0)

        def parameters(self):
            return self.getTypedRuleContext(dafnyParser.ParametersContext,0)


        def sequence(self):
            return self.getTypedRuleContext(dafnyParser.SequenceContext,0)


        def verifierAnnotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.VerifierAnnotationContext)
            else:
                return self.getTypedRuleContext(dafnyParser.VerifierAnnotationContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_constructorDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstructorDecl" ):
                listener.enterConstructorDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstructorDecl" ):
                listener.exitConstructorDecl(self)




    def constructorDecl(self):

        localctx = dafnyParser.ConstructorDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_constructorDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 394
            self.match(dafnyParser.CONSTRUCTOR)
            self.state = 395
            self.parameters()
            self.state = 399
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 70931694131085312) != 0):
                self.state = 396
                self.verifierAnnotation()
                self.state = 401
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 402
            self.match(dafnyParser.T__3)
            self.state = 403
            self.sequence()
            self.state = 404
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DisjContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NOT(self, i:int=None):
            if i is None:
                return self.getTokens(dafnyParser.NOT)
            else:
                return self.getToken(dafnyParser.NOT, i)

        def getRuleIndex(self):
            return dafnyParser.RULE_disj

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDisj" ):
                listener.enterDisj(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDisj" ):
                listener.exitDisj(self)




    def disj(self):

        localctx = dafnyParser.DisjContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_disj)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 406
            self.match(dafnyParser.NOT)
            self.state = 407
            self.match(dafnyParser.NOT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def modulus(self):
            return self.getTypedRuleContext(dafnyParser.ModulusContext,0)


        def multisetConversion(self):
            return self.getTypedRuleContext(dafnyParser.MultisetConversionContext,0)


        def classInstantiation(self):
            return self.getTypedRuleContext(dafnyParser.ClassInstantiationContext,0)


        def datatypeInstantiation(self):
            return self.getTypedRuleContext(dafnyParser.DatatypeInstantiationContext,0)


        def functionCall(self):
            return self.getTypedRuleContext(dafnyParser.FunctionCallContext,0)


        def ternaryExpression(self):
            return self.getTypedRuleContext(dafnyParser.TernaryExpressionContext,0)


        def matchExpression(self):
            return self.getTypedRuleContext(dafnyParser.MatchExpressionContext,0)


        def arrayLength(self):
            return self.getTypedRuleContext(dafnyParser.ArrayLengthContext,0)


        def literal(self):
            return self.getTypedRuleContext(dafnyParser.LiteralContext,0)


        def setDisplay(self):
            return self.getTypedRuleContext(dafnyParser.SetDisplayContext,0)


        def setComprehension(self):
            return self.getTypedRuleContext(dafnyParser.SetComprehensionContext,0)


        def sequenceDisplay(self):
            return self.getTypedRuleContext(dafnyParser.SequenceDisplayContext,0)


        def sequenceComprehension(self):
            return self.getTypedRuleContext(dafnyParser.SequenceComprehensionContext,0)


        def mapConstructor(self):
            return self.getTypedRuleContext(dafnyParser.MapConstructorContext,0)


        def mapComprehension(self):
            return self.getTypedRuleContext(dafnyParser.MapComprehensionContext,0)


        def identifier(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def unaryOperator(self):
            return self.getTypedRuleContext(dafnyParser.UnaryOperatorContext,0)


        def DOT(self):
            return self.getToken(dafnyParser.DOT, 0)

        def MUL(self):
            return self.getToken(dafnyParser.MUL, 0)

        def DIV(self):
            return self.getToken(dafnyParser.DIV, 0)

        def MOD(self):
            return self.getToken(dafnyParser.MOD, 0)

        def ADD(self):
            return self.getToken(dafnyParser.ADD, 0)

        def NEG(self):
            return self.getToken(dafnyParser.NEG, 0)

        def IN(self):
            return self.getToken(dafnyParser.IN, 0)

        def NOT_IN(self):
            return self.getToken(dafnyParser.NOT_IN, 0)

        def GT(self):
            return self.getToken(dafnyParser.GT, 0)

        def GEQ(self):
            return self.getToken(dafnyParser.GEQ, 0)

        def LT(self):
            return self.getToken(dafnyParser.LT, 0)

        def LEQ(self):
            return self.getToken(dafnyParser.LEQ, 0)

        def EQ(self):
            return self.getToken(dafnyParser.EQ, 0)

        def NEQ(self):
            return self.getToken(dafnyParser.NEQ, 0)

        def AND(self):
            return self.getToken(dafnyParser.AND, 0)

        def OR(self):
            return self.getToken(dafnyParser.OR, 0)

        def IMP(self):
            return self.getToken(dafnyParser.IMP, 0)

        def RIMP(self):
            return self.getToken(dafnyParser.RIMP, 0)

        def disj(self):
            return self.getTypedRuleContext(dafnyParser.DisjContext,0)


        def IFF(self):
            return self.getToken(dafnyParser.IFF, 0)

        def datatypeFieldUpdate(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.DatatypeFieldUpdateContext)
            else:
                return self.getTypedRuleContext(dafnyParser.DatatypeFieldUpdateContext,i)


        def indexElem(self):
            return self.getTypedRuleContext(dafnyParser.IndexElemContext,0)


        def index(self):
            return self.getTypedRuleContext(dafnyParser.IndexContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpression" ):
                listener.enterExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpression" ):
                listener.exitExpression(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = dafnyParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 68
        self.enterRecursionRule(localctx, 68, self.RULE_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 433
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.state = 410
                self.modulus()
                pass

            elif la_ == 2:
                self.state = 411
                self.multisetConversion()
                pass

            elif la_ == 3:
                self.state = 412
                self.classInstantiation()
                pass

            elif la_ == 4:
                self.state = 413
                self.datatypeInstantiation()
                pass

            elif la_ == 5:
                self.state = 414
                self.functionCall()
                pass

            elif la_ == 6:
                self.state = 415
                self.ternaryExpression()
                pass

            elif la_ == 7:
                self.state = 416
                self.matchExpression()
                pass

            elif la_ == 8:
                self.state = 417
                self.arrayLength()
                pass

            elif la_ == 9:
                self.state = 418
                self.literal()
                pass

            elif la_ == 10:
                self.state = 419
                self.setDisplay()
                pass

            elif la_ == 11:
                self.state = 420
                self.setComprehension()
                pass

            elif la_ == 12:
                self.state = 421
                self.sequenceDisplay()
                pass

            elif la_ == 13:
                self.state = 422
                self.sequenceComprehension()
                pass

            elif la_ == 14:
                self.state = 423
                self.mapConstructor()
                pass

            elif la_ == 15:
                self.state = 424
                self.mapComprehension()
                pass

            elif la_ == 16:
                self.state = 425
                self.identifier()
                pass

            elif la_ == 17:
                self.state = 426
                self.match(dafnyParser.T__6)
                self.state = 427
                self.expression(0)
                self.state = 428
                self.match(dafnyParser.T__7)
                pass

            elif la_ == 18:
                self.state = 430
                self.unaryOperator()
                self.state = 431
                self.expression(8)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 482
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,29,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 480
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,28,self._ctx)
                    if la_ == 1:
                        localctx = dafnyParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 435
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 436
                        self.match(dafnyParser.DOT)
                        self.state = 437
                        self.expression(13)
                        pass

                    elif la_ == 2:
                        localctx = dafnyParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 438
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 439
                        _la = self._input.LA(1)
                        if not(((((_la - 63)) & ~0x3f) == 0 and ((1 << (_la - 63)) & 7) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 440
                        self.expression(8)
                        pass

                    elif la_ == 3:
                        localctx = dafnyParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 441
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 442
                        _la = self._input.LA(1)
                        if not(((((_la - 61)) & ~0x3f) == 0 and ((1 << (_la - 61)) & 196611) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 443
                        self.expression(7)
                        pass

                    elif la_ == 4:
                        localctx = dafnyParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 444
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 445
                        _la = self._input.LA(1)
                        if not(((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & 63) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 446
                        self.expression(6)
                        pass

                    elif la_ == 5:
                        localctx = dafnyParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 447
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 448
                        _la = self._input.LA(1)
                        if not(_la==75 or _la==76):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 449
                        self.expression(5)
                        pass

                    elif la_ == 6:
                        localctx = dafnyParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 450
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 451
                        _la = self._input.LA(1)
                        if not(_la==72 or _la==73):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 452
                        self.expression(4)
                        pass

                    elif la_ == 7:
                        localctx = dafnyParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 453
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 454
                        self.disj()
                        self.state = 455
                        self.expression(3)
                        pass

                    elif la_ == 8:
                        localctx = dafnyParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 457
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 458
                        self.match(dafnyParser.IFF)
                        self.state = 459
                        self.expression(2)
                        pass

                    elif la_ == 9:
                        localctx = dafnyParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 460
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 461
                        self.match(dafnyParser.DOT)
                        self.state = 462
                        self.match(dafnyParser.T__6)
                        self.state = 463
                        self.datatypeFieldUpdate()
                        self.state = 468
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==1:
                            self.state = 464
                            self.match(dafnyParser.T__0)
                            self.state = 465
                            self.datatypeFieldUpdate()
                            self.state = 470
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 471
                        self.match(dafnyParser.T__7)
                        pass

                    elif la_ == 10:
                        localctx = dafnyParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 473
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 474
                        self.match(dafnyParser.T__8)
                        self.state = 475
                        self.indexElem()
                        self.state = 476
                        self.match(dafnyParser.T__9)
                        pass

                    elif la_ == 11:
                        localctx = dafnyParser.ExpressionContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 478
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 479
                        self.index()
                        pass

             
                self.state = 484
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class DatatypeFieldUpdateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierContext,0)


        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_datatypeFieldUpdate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatypeFieldUpdate" ):
                listener.enterDatatypeFieldUpdate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatypeFieldUpdate" ):
                listener.exitDatatypeFieldUpdate(self)




    def datatypeFieldUpdate(self):

        localctx = dafnyParser.DatatypeFieldUpdateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_datatypeFieldUpdate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 485
            self.identifier()
            self.state = 486
            self.match(dafnyParser.T__10)
            self.state = 487
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModulusContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_modulus

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModulus" ):
                listener.enterModulus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModulus" ):
                listener.exitModulus(self)




    def modulus(self):

        localctx = dafnyParser.ModulusContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_modulus)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 489
            self.match(dafnyParser.T__2)
            self.state = 490
            self.expression(0)
            self.state = 491
            self.match(dafnyParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultisetConversionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULTISET(self):
            return self.getToken(dafnyParser.MULTISET, 0)

        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_multisetConversion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultisetConversion" ):
                listener.enterMultisetConversion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultisetConversion" ):
                listener.exitMultisetConversion(self)




    def multisetConversion(self):

        localctx = dafnyParser.MultisetConversionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_multisetConversion)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 493
            self.match(dafnyParser.MULTISET)
            self.state = 494
            self.match(dafnyParser.T__6)
            self.state = 495
            self.expression(0)
            self.state = 496
            self.match(dafnyParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolLiteral(self):
            return self.getTypedRuleContext(dafnyParser.BoolLiteralContext,0)


        def intLiteral(self):
            return self.getTypedRuleContext(dafnyParser.IntLiteralContext,0)


        def realLiteral(self):
            return self.getTypedRuleContext(dafnyParser.RealLiteralContext,0)


        def charLiteral(self):
            return self.getTypedRuleContext(dafnyParser.CharLiteralContext,0)


        def stringToken(self):
            return self.getTypedRuleContext(dafnyParser.StringTokenContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)




    def literal(self):

        localctx = dafnyParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_literal)
        try:
            self.state = 503
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [81]:
                self.enterOuterAlt(localctx, 1)
                self.state = 498
                self.boolLiteral()
                pass
            elif token in [82]:
                self.enterOuterAlt(localctx, 2)
                self.state = 499
                self.intLiteral()
                pass
            elif token in [83]:
                self.enterOuterAlt(localctx, 3)
                self.state = 500
                self.realLiteral()
                pass
            elif token in [85]:
                self.enterOuterAlt(localctx, 4)
                self.state = 501
                self.charLiteral()
                pass
            elif token in [84]:
                self.enterOuterAlt(localctx, 5)
                self.state = 502
                self.stringToken()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_callParameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCallParameters" ):
                listener.enterCallParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCallParameters" ):
                listener.exitCallParameters(self)




    def callParameters(self):

        localctx = dafnyParser.CallParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_callParameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 505
            self.match(dafnyParser.T__6)
            self.state = 516
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 3747135765025391256) != 0) or ((((_la - 81)) & ~0x3f) == 0 and ((1 << (_la - 81)) & 127) != 0):
                self.state = 506
                self.expression(0)
                self.state = 511
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==1:
                    self.state = 507
                    self.match(dafnyParser.T__0)
                    self.state = 508
                    self.expression(0)
                    self.state = 513
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 518
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 519
            self.match(dafnyParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declAssignLhs(self):
            return self.getTypedRuleContext(dafnyParser.DeclAssignLhsContext,0)


        def callParameters(self):
            return self.getTypedRuleContext(dafnyParser.CallParametersContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_functionCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionCall" ):
                listener.enterFunctionCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionCall" ):
                listener.exitFunctionCall(self)




    def functionCall(self):

        localctx = dafnyParser.FunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_functionCall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 521
            self.declAssignLhs()
            self.state = 522
            self.callParameters()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ClassInstantiationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEW(self):
            return self.getToken(dafnyParser.NEW, 0)

        def upperIdentifier(self):
            return self.getTypedRuleContext(dafnyParser.UpperIdentifierContext,0)


        def callParameters(self):
            return self.getTypedRuleContext(dafnyParser.CallParametersContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_classInstantiation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterClassInstantiation" ):
                listener.enterClassInstantiation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitClassInstantiation" ):
                listener.exitClassInstantiation(self)




    def classInstantiation(self):

        localctx = dafnyParser.ClassInstantiationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_classInstantiation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 524
            self.match(dafnyParser.NEW)
            self.state = 525
            self.upperIdentifier()
            self.state = 526
            self.callParameters()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DatatypeInstantiationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def upperIdentifier(self):
            return self.getTypedRuleContext(dafnyParser.UpperIdentifierContext,0)


        def callParameters(self):
            return self.getTypedRuleContext(dafnyParser.CallParametersContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_datatypeInstantiation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatatypeInstantiation" ):
                listener.enterDatatypeInstantiation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatatypeInstantiation" ):
                listener.exitDatatypeInstantiation(self)




    def datatypeInstantiation(self):

        localctx = dafnyParser.DatatypeInstantiationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_datatypeInstantiation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 528
            self.upperIdentifier()
            self.state = 529
            self.callParameters()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TernaryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(dafnyParser.IF, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def ELSE(self):
            return self.getToken(dafnyParser.ELSE, 0)

        def THEN(self):
            return self.getToken(dafnyParser.THEN, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_ternaryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTernaryExpression" ):
                listener.enterTernaryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTernaryExpression" ):
                listener.exitTernaryExpression(self)




    def ternaryExpression(self):

        localctx = dafnyParser.TernaryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_ternaryExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 531
            self.match(dafnyParser.IF)
            self.state = 537
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.state = 532
                self.match(dafnyParser.T__6)
                self.state = 533
                self.expression(0)
                self.state = 534
                self.match(dafnyParser.T__7)
                pass

            elif la_ == 2:
                self.state = 536
                self.expression(0)
                pass


            self.state = 540
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==39:
                self.state = 539
                self.match(dafnyParser.THEN)


            self.state = 542
            self.expression(0)
            self.state = 543
            self.match(dafnyParser.ELSE)
            self.state = 544
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatchExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MATCH(self):
            return self.getToken(dafnyParser.MATCH, 0)

        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def caseExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.CaseExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.CaseExpressionContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_matchExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatchExpression" ):
                listener.enterMatchExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatchExpression" ):
                listener.exitMatchExpression(self)




    def matchExpression(self):

        localctx = dafnyParser.MatchExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_matchExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 546
            self.match(dafnyParser.MATCH)
            self.state = 547
            self.expression(0)
            self.state = 548
            self.match(dafnyParser.T__3)
            self.state = 550 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 549
                self.caseExpression()
                self.state = 552 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==48):
                    break

            self.state = 554
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(dafnyParser.CASE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_caseExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseExpression" ):
                listener.enterCaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseExpression" ):
                listener.exitCaseExpression(self)




    def caseExpression(self):

        localctx = dafnyParser.CaseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_caseExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 556
            self.match(dafnyParser.CASE)
            self.state = 557
            self.expression(0)
            self.state = 558
            self.match(dafnyParser.T__11)
            self.state = 559
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayLengthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declAssignLhs(self):
            return self.getTypedRuleContext(dafnyParser.DeclAssignLhsContext,0)


        def DOT(self):
            return self.getToken(dafnyParser.DOT, 0)

        def LENGTH(self):
            return self.getToken(dafnyParser.LENGTH, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_arrayLength

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayLength" ):
                listener.enterArrayLength(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayLength" ):
                listener.exitArrayLength(self)




    def arrayLength(self):

        localctx = dafnyParser.ArrayLengthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_arrayLength)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 561
            self.declAssignLhs()
            self.state = 562
            self.match(dafnyParser.DOT)
            self.state = 563
            self.match(dafnyParser.LENGTH)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_index

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex" ):
                listener.enterIndex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex" ):
                listener.exitIndex(self)




    def index(self):

        localctx = dafnyParser.IndexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_index)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 565
            self.match(dafnyParser.T__8)
            self.state = 566
            self.expression(0)
            self.state = 571
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1:
                self.state = 567
                self.match(dafnyParser.T__0)
                self.state = 568
                self.expression(0)
                self.state = 573
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 574
            self.match(dafnyParser.T__9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetDisplayContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MULTISET(self):
            return self.getToken(dafnyParser.MULTISET, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_setDisplay

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetDisplay" ):
                listener.enterSetDisplay(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetDisplay" ):
                listener.exitSetDisplay(self)




    def setDisplay(self):

        localctx = dafnyParser.SetDisplayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_setDisplay)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 577
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==25:
                self.state = 576
                self.match(dafnyParser.MULTISET)


            self.state = 579
            self.match(dafnyParser.T__3)
            self.state = 588
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 3747135765025391256) != 0) or ((((_la - 81)) & ~0x3f) == 0 and ((1 << (_la - 81)) & 127) != 0):
                self.state = 580
                self.expression(0)
                self.state = 585
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==1:
                    self.state = 581
                    self.match(dafnyParser.T__0)
                    self.state = 582
                    self.expression(0)
                    self.state = 587
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 590
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetComprehensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(dafnyParser.SET, 0)

        def identifierType(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierTypeContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_setComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSetComprehension" ):
                listener.enterSetComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSetComprehension" ):
                listener.exitSetComprehension(self)




    def setComprehension(self):

        localctx = dafnyParser.SetComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_setComprehension)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 592
            self.match(dafnyParser.SET)
            self.state = 593
            self.identifierType()
            self.state = 594
            self.match(dafnyParser.T__2)
            self.state = 595
            self.expression(0)
            self.state = 596
            self.match(dafnyParser.T__12)
            self.state = 597
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SequenceDisplayContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_sequenceDisplay

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequenceDisplay" ):
                listener.enterSequenceDisplay(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequenceDisplay" ):
                listener.exitSequenceDisplay(self)




    def sequenceDisplay(self):

        localctx = dafnyParser.SequenceDisplayContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_sequenceDisplay)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 599
            self.match(dafnyParser.T__8)
            self.state = 608
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 3747135765025391256) != 0) or ((((_la - 81)) & ~0x3f) == 0 and ((1 << (_la - 81)) & 127) != 0):
                self.state = 600
                self.expression(0)
                self.state = 605
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==1:
                    self.state = 601
                    self.match(dafnyParser.T__0)
                    self.state = 602
                    self.expression(0)
                    self.state = 607
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 610
            self.match(dafnyParser.T__9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SequenceComprehensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SEQUENCE(self):
            return self.getToken(dafnyParser.SEQUENCE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def identifier(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierContext,0)


        def verifierAnnotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.VerifierAnnotationContext)
            else:
                return self.getTypedRuleContext(dafnyParser.VerifierAnnotationContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_sequenceComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequenceComprehension" ):
                listener.enterSequenceComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequenceComprehension" ):
                listener.exitSequenceComprehension(self)




    def sequenceComprehension(self):

        localctx = dafnyParser.SequenceComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_sequenceComprehension)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 612
            self.match(dafnyParser.SEQUENCE)
            self.state = 613
            self.match(dafnyParser.T__6)
            self.state = 614
            self.expression(0)
            self.state = 615
            self.match(dafnyParser.T__0)
            self.state = 616
            self.identifier()
            self.state = 620
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 70931694131085312) != 0):
                self.state = 617
                self.verifierAnnotation()
                self.state = 622
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 623
            self.match(dafnyParser.T__11)
            self.state = 624
            self.expression(0)
            self.state = 625
            self.match(dafnyParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MapConstructorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAP(self):
            return self.getToken(dafnyParser.MAP, 0)

        def indexElem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.IndexElemContext)
            else:
                return self.getTypedRuleContext(dafnyParser.IndexElemContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_mapConstructor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMapConstructor" ):
                listener.enterMapConstructor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMapConstructor" ):
                listener.exitMapConstructor(self)




    def mapConstructor(self):

        localctx = dafnyParser.MapConstructorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_mapConstructor)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 627
            self.match(dafnyParser.MAP)
            self.state = 628
            self.match(dafnyParser.T__8)
            self.state = 637
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 3747135765025391256) != 0) or ((((_la - 81)) & ~0x3f) == 0 and ((1 << (_la - 81)) & 127) != 0):
                self.state = 629
                self.indexElem()
                self.state = 634
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==1:
                    self.state = 630
                    self.match(dafnyParser.T__0)
                    self.state = 631
                    self.indexElem()
                    self.state = 636
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 639
            self.match(dafnyParser.T__9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MapComprehensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAP(self):
            return self.getToken(dafnyParser.MAP, 0)

        def identifierType(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierTypeContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_mapComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMapComprehension" ):
                listener.enterMapComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMapComprehension" ):
                listener.exitMapComprehension(self)




    def mapComprehension(self):

        localctx = dafnyParser.MapComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_mapComprehension)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 641
            self.match(dafnyParser.MAP)
            self.state = 642
            self.identifierType()
            self.state = 643
            self.match(dafnyParser.T__2)
            self.state = 644
            self.expression(0)
            self.state = 645
            self.match(dafnyParser.T__12)
            self.state = 646
            self.expression(0)
            self.state = 647
            self.match(dafnyParser.T__10)
            self.state = 648
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexElemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_indexElem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexElem" ):
                listener.enterIndexElem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexElem" ):
                listener.exitIndexElem(self)




    def indexElem(self):

        localctx = dafnyParser.IndexElemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_indexElem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 650
            self.expression(0)
            self.state = 651
            self.match(dafnyParser.T__10)
            self.state = 652
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assertStatement(self):
            return self.getTypedRuleContext(dafnyParser.AssertStatementContext,0)


        def breakStatement(self):
            return self.getTypedRuleContext(dafnyParser.BreakStatementContext,0)


        def continueStatement(self):
            return self.getTypedRuleContext(dafnyParser.ContinueStatementContext,0)


        def voidMethodCall(self):
            return self.getTypedRuleContext(dafnyParser.VoidMethodCallContext,0)


        def declaration(self):
            return self.getTypedRuleContext(dafnyParser.DeclarationContext,0)


        def assignment(self):
            return self.getTypedRuleContext(dafnyParser.AssignmentContext,0)


        def print_(self):
            return self.getTypedRuleContext(dafnyParser.PrintContext,0)


        def matchStatement(self):
            return self.getTypedRuleContext(dafnyParser.MatchStatementContext,0)


        def ifStatement(self):
            return self.getTypedRuleContext(dafnyParser.IfStatementContext,0)


        def forallStatement(self):
            return self.getTypedRuleContext(dafnyParser.ForallStatementContext,0)


        def forLoop(self):
            return self.getTypedRuleContext(dafnyParser.ForLoopContext,0)


        def whileStatement(self):
            return self.getTypedRuleContext(dafnyParser.WhileStatementContext,0)


        def ghostVarDecl(self):
            return self.getTypedRuleContext(dafnyParser.GhostVarDeclContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = dafnyParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_statement)
        try:
            self.state = 667
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,45,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 654
                self.assertStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 655
                self.breakStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 656
                self.continueStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 657
                self.voidMethodCall()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 658
                self.declaration()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 659
                self.assignment()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 660
                self.print_()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 661
                self.matchStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 662
                self.ifStatement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 663
                self.forallStatement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 664
                self.forLoop()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 665
                self.whileStatement()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 666
                self.ghostVarDecl()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssertStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSERT(self):
            return self.getToken(dafnyParser.ASSERT, 0)

        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_assertStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssertStatement" ):
                listener.enterAssertStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssertStatement" ):
                listener.exitAssertStatement(self)




    def assertStatement(self):

        localctx = dafnyParser.AssertStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_assertStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 669
            self.match(dafnyParser.ASSERT)
            self.state = 670
            self.expression(0)
            self.state = 671
            self.match(dafnyParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BreakStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BREAK(self):
            return self.getToken(dafnyParser.BREAK, 0)

        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_breakStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreakStatement" ):
                listener.enterBreakStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreakStatement" ):
                listener.exitBreakStatement(self)




    def breakStatement(self):

        localctx = dafnyParser.BreakStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_breakStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 673
            self.match(dafnyParser.BREAK)
            self.state = 674
            self.match(dafnyParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContinueStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONTINUE(self):
            return self.getToken(dafnyParser.CONTINUE, 0)

        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_continueStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinueStatement" ):
                listener.enterContinueStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinueStatement" ):
                listener.exitContinueStatement(self)




    def continueStatement(self):

        localctx = dafnyParser.ContinueStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_continueStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 676
            self.match(dafnyParser.CONTINUE)
            self.state = 677
            self.match(dafnyParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclIdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_declIdentifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclIdentifier" ):
                listener.enterDeclIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclIdentifier" ):
                listener.exitDeclIdentifier(self)




    def declIdentifier(self):

        localctx = dafnyParser.DeclIdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_declIdentifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 679
            self.identifier()
            self.state = 693
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==9:
                self.state = 680
                self.match(dafnyParser.T__8)
                self.state = 681
                self.expression(0)
                self.state = 686
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==1:
                    self.state = 682
                    self.match(dafnyParser.T__0)
                    self.state = 683
                    self.expression(0)
                    self.state = 688
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 689
                self.match(dafnyParser.T__9)
                self.state = 695
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclAssignLhsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declIdentifier(self):
            return self.getTypedRuleContext(dafnyParser.DeclIdentifierContext,0)


        def DOT(self):
            return self.getToken(dafnyParser.DOT, 0)

        def declAssignLhs(self):
            return self.getTypedRuleContext(dafnyParser.DeclAssignLhsContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_declAssignLhs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclAssignLhs" ):
                listener.enterDeclAssignLhs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclAssignLhs" ):
                listener.exitDeclAssignLhs(self)




    def declAssignLhs(self):

        localctx = dafnyParser.DeclAssignLhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_declAssignLhs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 696
            self.declIdentifier()
            self.state = 699
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
            if la_ == 1:
                self.state = 697
                self.match(dafnyParser.DOT)
                self.state = 698
                self.declAssignLhs()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclAssignRhsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def arrayConstructor(self):
            return self.getTypedRuleContext(dafnyParser.ArrayConstructorContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_declAssignRhs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclAssignRhs" ):
                listener.enterDeclAssignRhs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclAssignRhs" ):
                listener.exitDeclAssignRhs(self)




    def declAssignRhs(self):

        localctx = dafnyParser.DeclAssignRhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_declAssignRhs)
        try:
            self.state = 710
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 701
                self.expression(0)
                self.state = 706
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,49,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 702
                        self.match(dafnyParser.T__0)
                        self.state = 703
                        self.expression(0) 
                    self.state = 708
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,49,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 709
                self.arrayConstructor()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationLhsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VAR(self):
            return self.getToken(dafnyParser.VAR, 0)

        def declAssignLhs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.DeclAssignLhsContext)
            else:
                return self.getTypedRuleContext(dafnyParser.DeclAssignLhsContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_declarationLhs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarationLhs" ):
                listener.enterDeclarationLhs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarationLhs" ):
                listener.exitDeclarationLhs(self)




    def declarationLhs(self):

        localctx = dafnyParser.DeclarationLhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_declarationLhs)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 712
            self.match(dafnyParser.VAR)
            self.state = 713
            self.declAssignLhs()
            self.state = 718
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1:
                self.state = 714
                self.match(dafnyParser.T__0)
                self.state = 715
                self.declAssignLhs()
                self.state = 720
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declarationLhs(self):
            return self.getTypedRuleContext(dafnyParser.DeclarationLhsContext,0)


        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def type_(self):
            return self.getTypedRuleContext(dafnyParser.TypeContext,0)


        def declAssignRhs(self):
            return self.getTypedRuleContext(dafnyParser.DeclAssignRhsContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)




    def declaration(self):

        localctx = dafnyParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 721
            self.declarationLhs()
            self.state = 724
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 722
                self.match(dafnyParser.T__5)
                self.state = 723
                self.type_()


            self.state = 728
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 726
                self.match(dafnyParser.T__10)
                self.state = 727
                self.declAssignRhs()


            self.state = 730
            self.match(dafnyParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentLhsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declAssignLhs(self):
            return self.getTypedRuleContext(dafnyParser.DeclAssignLhsContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_assignmentLhs

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignmentLhs" ):
                listener.enterAssignmentLhs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignmentLhs" ):
                listener.exitAssignmentLhs(self)




    def assignmentLhs(self):

        localctx = dafnyParser.AssignmentLhsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_assignmentLhs)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 732
            self.declAssignLhs()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignmentLhs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.AssignmentLhsContext)
            else:
                return self.getTypedRuleContext(dafnyParser.AssignmentLhsContext,i)


        def declAssignRhs(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.DeclAssignRhsContext)
            else:
                return self.getTypedRuleContext(dafnyParser.DeclAssignRhsContext,i)


        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment" ):
                listener.enterAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment" ):
                listener.exitAssignment(self)




    def assignment(self):

        localctx = dafnyParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_assignment)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 734
            self.assignmentLhs()
            self.state = 739
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1:
                self.state = 735
                self.match(dafnyParser.T__0)
                self.state = 736
                self.assignmentLhs()
                self.state = 741
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 742
            self.match(dafnyParser.T__10)
            self.state = 743
            self.declAssignRhs()
            self.state = 748
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1:
                self.state = 744
                self.match(dafnyParser.T__0)
                self.state = 745
                self.declAssignRhs()
                self.state = 750
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 751
            self.match(dafnyParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRINT(self):
            return self.getToken(dafnyParser.PRINT, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_print

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrint" ):
                listener.enterPrint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrint" ):
                listener.exitPrint(self)




    def print_(self):

        localctx = dafnyParser.PrintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_print)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 753
            self.match(dafnyParser.PRINT)
            self.state = 754
            self.expression(0)
            self.state = 759
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1:
                self.state = 755
                self.match(dafnyParser.T__0)
                self.state = 756
                self.expression(0)
                self.state = 761
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 762
            self.match(dafnyParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VoidMethodCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def declAssignLhs(self):
            return self.getTypedRuleContext(dafnyParser.DeclAssignLhsContext,0)


        def callParameters(self):
            return self.getTypedRuleContext(dafnyParser.CallParametersContext,0)


        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_voidMethodCall

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVoidMethodCall" ):
                listener.enterVoidMethodCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVoidMethodCall" ):
                listener.exitVoidMethodCall(self)




    def voidMethodCall(self):

        localctx = dafnyParser.VoidMethodCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_voidMethodCall)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 764
            self.declAssignLhs()
            self.state = 765
            self.callParameters()
            self.state = 766
            self.match(dafnyParser.SEMICOLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatchStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MATCH(self):
            return self.getToken(dafnyParser.MATCH, 0)

        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def caseStatement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.CaseStatementContext)
            else:
                return self.getTypedRuleContext(dafnyParser.CaseStatementContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_matchStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatchStatement" ):
                listener.enterMatchStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatchStatement" ):
                listener.exitMatchStatement(self)




    def matchStatement(self):

        localctx = dafnyParser.MatchStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_matchStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 768
            self.match(dafnyParser.MATCH)
            self.state = 769
            self.expression(0)
            self.state = 770
            self.match(dafnyParser.T__3)
            self.state = 772 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 771
                self.caseStatement()
                self.state = 774 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==48):
                    break

            self.state = 776
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self):
            return self.getToken(dafnyParser.CASE, 0)

        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def sequence(self):
            return self.getTypedRuleContext(dafnyParser.SequenceContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_caseStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCaseStatement" ):
                listener.enterCaseStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCaseStatement" ):
                listener.exitCaseStatement(self)




    def caseStatement(self):

        localctx = dafnyParser.CaseStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_caseStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 778
            self.match(dafnyParser.CASE)
            self.state = 779
            self.expression(0)
            self.state = 780
            self.match(dafnyParser.T__11)
            self.state = 781
            self.sequence()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(dafnyParser.IF, 0)

        def sequence(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.SequenceContext)
            else:
                return self.getTypedRuleContext(dafnyParser.SequenceContext,i)


        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def ELSE(self):
            return self.getToken(dafnyParser.ELSE, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)




    def ifStatement(self):

        localctx = dafnyParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_ifStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 783
            self.match(dafnyParser.IF)
            self.state = 789
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
            if la_ == 1:
                self.state = 784
                self.match(dafnyParser.T__6)
                self.state = 785
                self.expression(0)
                self.state = 786
                self.match(dafnyParser.T__7)
                pass

            elif la_ == 2:
                self.state = 788
                self.expression(0)
                pass


            self.state = 791
            self.match(dafnyParser.T__3)
            self.state = 792
            self.sequence()
            self.state = 793
            self.match(dafnyParser.T__4)
            self.state = 799
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==38:
                self.state = 794
                self.match(dafnyParser.ELSE)
                self.state = 795
                self.match(dafnyParser.T__3)
                self.state = 796
                self.sequence()
                self.state = 797
                self.match(dafnyParser.T__4)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForallStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FORALL(self):
            return self.getToken(dafnyParser.FORALL, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(dafnyParser.IdentifierContext,i)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def LEQ(self):
            return self.getToken(dafnyParser.LEQ, 0)

        def LT(self):
            return self.getToken(dafnyParser.LT, 0)

        def assignment(self):
            return self.getTypedRuleContext(dafnyParser.AssignmentContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_forallStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForallStatement" ):
                listener.enterForallStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForallStatement" ):
                listener.exitForallStatement(self)




    def forallStatement(self):

        localctx = dafnyParser.ForallStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_forallStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 801
            self.match(dafnyParser.FORALL)
            self.state = 802
            self.identifier()
            self.state = 803
            self.match(dafnyParser.T__2)
            self.state = 804
            self.expression(0)
            self.state = 805
            self.match(dafnyParser.LEQ)
            self.state = 806
            self.identifier()
            self.state = 807
            self.match(dafnyParser.LT)
            self.state = 808
            self.expression(0)
            self.state = 809
            self.match(dafnyParser.T__3)
            self.state = 810
            self.assignment()
            self.state = 811
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForLoopContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(dafnyParser.FOR, 0)

        def identifier(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierContext,0)


        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def TO(self):
            return self.getToken(dafnyParser.TO, 0)

        def sequence(self):
            return self.getTypedRuleContext(dafnyParser.SequenceContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_forLoop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForLoop" ):
                listener.enterForLoop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForLoop" ):
                listener.exitForLoop(self)




    def forLoop(self):

        localctx = dafnyParser.ForLoopContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_forLoop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 813
            self.match(dafnyParser.FOR)
            self.state = 814
            self.identifier()
            self.state = 815
            self.match(dafnyParser.T__10)
            self.state = 816
            self.expression(0)
            self.state = 817
            self.match(dafnyParser.TO)
            self.state = 818
            self.expression(0)
            self.state = 819
            self.match(dafnyParser.T__3)
            self.state = 820
            self.sequence()
            self.state = 821
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHILE(self):
            return self.getToken(dafnyParser.WHILE, 0)

        def sequence(self):
            return self.getTypedRuleContext(dafnyParser.SequenceContext,0)


        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def verifierAnnotation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.VerifierAnnotationContext)
            else:
                return self.getTypedRuleContext(dafnyParser.VerifierAnnotationContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_whileStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhileStatement" ):
                listener.enterWhileStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhileStatement" ):
                listener.exitWhileStatement(self)




    def whileStatement(self):

        localctx = dafnyParser.WhileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_whileStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 823
            self.match(dafnyParser.WHILE)
            self.state = 829
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
            if la_ == 1:
                self.state = 824
                self.match(dafnyParser.T__6)
                self.state = 825
                self.expression(0)
                self.state = 826
                self.match(dafnyParser.T__7)
                pass

            elif la_ == 2:
                self.state = 828
                self.expression(0)
                pass


            self.state = 834
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 70931694131085312) != 0):
                self.state = 831
                self.verifierAnnotation()
                self.state = 836
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 837
            self.match(dafnyParser.T__3)
            self.state = 838
            self.sequence()
            self.state = 839
            self.match(dafnyParser.T__4)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GhostVarDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GHOST(self):
            return self.getToken(dafnyParser.GHOST, 0)

        def VAR(self):
            return self.getToken(dafnyParser.VAR, 0)

        def identifierType(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierTypeContext,0)


        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_ghostVarDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGhostVarDecl" ):
                listener.enterGhostVarDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGhostVarDecl" ):
                listener.exitGhostVarDecl(self)




    def ghostVarDecl(self):

        localctx = dafnyParser.GhostVarDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_ghostVarDecl)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 841
            self.match(dafnyParser.GHOST)
            self.state = 842
            self.match(dafnyParser.VAR)
            self.state = 843
            self.identifierType()
            self.state = 845
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==80:
                self.state = 844
                self.match(dafnyParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerifierAnnotationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decreases(self):
            return self.getTypedRuleContext(dafnyParser.DecreasesContext,0)


        def ensures(self):
            return self.getTypedRuleContext(dafnyParser.EnsuresContext,0)


        def invariant(self):
            return self.getTypedRuleContext(dafnyParser.InvariantContext,0)


        def modifies(self):
            return self.getTypedRuleContext(dafnyParser.ModifiesContext,0)


        def reads(self):
            return self.getTypedRuleContext(dafnyParser.ReadsContext,0)


        def requires(self):
            return self.getTypedRuleContext(dafnyParser.RequiresContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_verifierAnnotation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerifierAnnotation" ):
                listener.enterVerifierAnnotation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerifierAnnotation" ):
                listener.exitVerifierAnnotation(self)




    def verifierAnnotation(self):

        localctx = dafnyParser.VerifierAnnotationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_verifierAnnotation)
        try:
            self.state = 853
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [50]:
                self.enterOuterAlt(localctx, 1)
                self.state = 847
                self.decreases()
                pass
            elif token in [51]:
                self.enterOuterAlt(localctx, 2)
                self.state = 848
                self.ensures()
                pass
            elif token in [55]:
                self.enterOuterAlt(localctx, 3)
                self.state = 849
                self.invariant()
                pass
            elif token in [54]:
                self.enterOuterAlt(localctx, 4)
                self.state = 850
                self.modifies()
                pass
            elif token in [53]:
                self.enterOuterAlt(localctx, 5)
                self.state = 851
                self.reads()
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 6)
                self.state = 852
                self.requires()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecreasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECREASES(self):
            return self.getToken(dafnyParser.DECREASES, 0)

        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_decreases

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecreases" ):
                listener.enterDecreases(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecreases" ):
                listener.exitDecreases(self)




    def decreases(self):

        localctx = dafnyParser.DecreasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_decreases)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 855
            self.match(dafnyParser.DECREASES)
            self.state = 856
            self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnsuresContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENSURES(self):
            return self.getToken(dafnyParser.ENSURES, 0)

        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_ensures

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnsures" ):
                listener.enterEnsures(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnsures" ):
                listener.exitEnsures(self)




    def ensures(self):

        localctx = dafnyParser.EnsuresContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_ensures)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 858
            self.match(dafnyParser.ENSURES)
            self.state = 859
            self.expression(0)
            self.state = 861
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==80:
                self.state = 860
                self.match(dafnyParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InvariantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INVARIANT(self):
            return self.getToken(dafnyParser.INVARIANT, 0)

        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_invariant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInvariant" ):
                listener.enterInvariant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInvariant" ):
                listener.exitInvariant(self)




    def invariant(self):

        localctx = dafnyParser.InvariantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_invariant)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 863
            self.match(dafnyParser.INVARIANT)
            self.state = 864
            self.expression(0)
            self.state = 866
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==80:
                self.state = 865
                self.match(dafnyParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ModifiesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MODIFIES(self):
            return self.getToken(dafnyParser.MODIFIES, 0)

        def identifier(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierContext,0)


        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_modifies

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModifies" ):
                listener.enterModifies(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModifies" ):
                listener.exitModifies(self)




    def modifies(self):

        localctx = dafnyParser.ModifiesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_modifies)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 868
            self.match(dafnyParser.MODIFIES)
            self.state = 869
            self.identifier()
            self.state = 871
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==80:
                self.state = 870
                self.match(dafnyParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReadsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def READS(self):
            return self.getToken(dafnyParser.READS, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(dafnyParser.IdentifierContext,i)


        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_reads

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReads" ):
                listener.enterReads(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReads" ):
                listener.exitReads(self)




    def reads(self):

        localctx = dafnyParser.ReadsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_reads)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 873
            self.match(dafnyParser.READS)
            self.state = 874
            self.identifier()

            self.state = 875
            self.match(dafnyParser.T__0)
            self.state = 879
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==87:
                self.state = 876
                self.identifier()
                self.state = 881
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 883
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==80:
                self.state = 882
                self.match(dafnyParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RequiresContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REQUIRES(self):
            return self.getToken(dafnyParser.REQUIRES, 0)

        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def SEMICOLON(self):
            return self.getToken(dafnyParser.SEMICOLON, 0)

        def getRuleIndex(self):
            return dafnyParser.RULE_requires

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRequires" ):
                listener.enterRequires(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRequires" ):
                listener.exitRequires(self)




    def requires(self):

        localctx = dafnyParser.RequiresContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_requires)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 885
            self.match(dafnyParser.REQUIRES)
            self.state = 886
            self.expression(0)
            self.state = 888
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==80:
                self.state = 887
                self.match(dafnyParser.SEMICOLON)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayConstructorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEW(self):
            return self.getToken(dafnyParser.NEW, 0)

        def type_(self):
            return self.getTypedRuleContext(dafnyParser.TypeContext,0)


        def intLiteral(self):
            return self.getTypedRuleContext(dafnyParser.IntLiteralContext,0)


        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def arrayComprehension(self):
            return self.getTypedRuleContext(dafnyParser.ArrayComprehensionContext,0)


        def arrayValues(self):
            return self.getTypedRuleContext(dafnyParser.ArrayValuesContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_arrayConstructor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayConstructor" ):
                listener.enterArrayConstructor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayConstructor" ):
                listener.exitArrayConstructor(self)




    def arrayConstructor(self):

        localctx = dafnyParser.ArrayConstructorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_arrayConstructor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 890
            self.match(dafnyParser.NEW)
            self.state = 891
            self.type_()
            self.state = 892
            self.match(dafnyParser.T__8)
            self.state = 895
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 893
                self.intLiteral()
                pass

            elif la_ == 2:
                self.state = 894
                self.expression(0)
                pass


            self.state = 897
            self.match(dafnyParser.T__9)
            self.state = 900
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7]:
                self.state = 898
                self.arrayComprehension()
                pass
            elif token in [9]:
                self.state = 899
                self.arrayValues()
                pass
            elif token in [1, 80]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayComprehensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(dafnyParser.IdentifierContext,0)


        def expression(self):
            return self.getTypedRuleContext(dafnyParser.ExpressionContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_arrayComprehension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayComprehension" ):
                listener.enterArrayComprehension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayComprehension" ):
                listener.exitArrayComprehension(self)




    def arrayComprehension(self):

        localctx = dafnyParser.ArrayComprehensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_arrayComprehension)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 902
            self.match(dafnyParser.T__6)
            self.state = 903
            self.identifier()
            self.state = 904
            self.match(dafnyParser.T__11)
            self.state = 905
            self.expression(0)
            self.state = 906
            self.match(dafnyParser.T__7)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArrayValuesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(dafnyParser.ExpressionContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_arrayValues

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArrayValues" ):
                listener.enterArrayValues(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArrayValues" ):
                listener.exitArrayValues(self)




    def arrayValues(self):

        localctx = dafnyParser.ArrayValuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_arrayValues)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 908
            self.match(dafnyParser.T__8)
            self.state = 909
            self.expression(0)
            self.state = 914
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==1:
                self.state = 910
                self.match(dafnyParser.T__0)
                self.state = 911
                self.expression(0)
                self.state = 916
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 917
            self.match(dafnyParser.T__9)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopDeclMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionDecl(self):
            return self.getTypedRuleContext(dafnyParser.FunctionDeclContext,0)


        def methodDecl(self):
            return self.getTypedRuleContext(dafnyParser.MethodDeclContext,0)


        def getRuleIndex(self):
            return dafnyParser.RULE_topDeclMember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopDeclMember" ):
                listener.enterTopDeclMember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopDeclMember" ):
                listener.exitTopDeclMember(self)




    def topDeclMember(self):

        localctx = dafnyParser.TopDeclMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_topDeclMember)
        try:
            self.state = 921
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [32]:
                self.enterOuterAlt(localctx, 1)
                self.state = 919
                self.functionDecl()
                pass
            elif token in [31]:
                self.enterOuterAlt(localctx, 2)
                self.state = 920
                self.methodDecl()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ProgramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def topDecl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(dafnyParser.TopDeclContext)
            else:
                return self.getTypedRuleContext(dafnyParser.TopDeclContext,i)


        def getRuleIndex(self):
            return dafnyParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = dafnyParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 926
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 7381975040) != 0):
                self.state = 923
                self.topDecl()
                self.state = 928
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[34] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 1)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 9)
         




